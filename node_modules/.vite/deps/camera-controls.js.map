{
  "version": 3,
  "sources": ["../../camera-controls/dist/camera-controls.module.js"],
  "sourcesContent": ["/*!\r\n * camera-controls\r\n * https://github.com/yomotsu/camera-controls\r\n * (c) 2017 @yomotsu\r\n * Released under the MIT License.\r\n */\r\n// see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#value\r\nconst MOUSE_BUTTON = {\r\n    LEFT: 1,\r\n    RIGHT: 2,\r\n    MIDDLE: 4,\r\n};\r\nconst ACTION = Object.freeze({\r\n    NONE: 0,\r\n    ROTATE: 1,\r\n    TRUCK: 2,\r\n    OFFSET: 4,\r\n    DOLLY: 8,\r\n    ZOOM: 16,\r\n    TOUCH_ROTATE: 32,\r\n    TOUCH_TRUCK: 64,\r\n    TOUCH_OFFSET: 128,\r\n    TOUCH_DOLLY: 256,\r\n    TOUCH_ZOOM: 512,\r\n    TOUCH_DOLLY_TRUCK: 1024,\r\n    TOUCH_DOLLY_OFFSET: 2048,\r\n    TOUCH_DOLLY_ROTATE: 4096,\r\n    TOUCH_ZOOM_TRUCK: 8192,\r\n    TOUCH_ZOOM_OFFSET: 16384,\r\n    TOUCH_ZOOM_ROTATE: 32768,\r\n});\r\nconst DOLLY_DIRECTION = {\r\n    NONE: 0,\r\n    IN: 1,\r\n    OUT: -1,\r\n};\r\nfunction isPerspectiveCamera(camera) {\r\n    return camera.isPerspectiveCamera;\r\n}\r\nfunction isOrthographicCamera(camera) {\r\n    return camera.isOrthographicCamera;\r\n}\r\n\r\nconst PI_2 = Math.PI * 2;\r\nconst PI_HALF = Math.PI / 2;\r\n\r\nconst EPSILON = 1e-5;\r\nconst DEG2RAD = Math.PI / 180;\r\nfunction clamp(value, min, max) {\r\n    return Math.max(min, Math.min(max, value));\r\n}\r\nfunction approxZero(number, error = EPSILON) {\r\n    return Math.abs(number) < error;\r\n}\r\nfunction approxEquals(a, b, error = EPSILON) {\r\n    return approxZero(a - b, error);\r\n}\r\nfunction roundToStep(value, step) {\r\n    return Math.round(value / step) * step;\r\n}\r\nfunction infinityToMaxNumber(value) {\r\n    if (isFinite(value))\r\n        return value;\r\n    if (value < 0)\r\n        return -Number.MAX_VALUE;\r\n    return Number.MAX_VALUE;\r\n}\r\nfunction maxNumberToInfinity(value) {\r\n    if (Math.abs(value) < Number.MAX_VALUE)\r\n        return value;\r\n    return value * Infinity;\r\n}\r\n// https://docs.unity3d.com/ScriptReference/Mathf.SmoothDamp.html\r\n// https://github.com/Unity-Technologies/UnityCsReference/blob/a2bdfe9b3c4cd4476f44bf52f848063bfaf7b6b9/Runtime/Export/Math/Mathf.cs#L308\r\nfunction smoothDamp(current, target, currentVelocityRef, smoothTime, maxSpeed = Infinity, deltaTime) {\r\n    // Based on Game Programming Gems 4 Chapter 1.10\r\n    smoothTime = Math.max(0.0001, smoothTime);\r\n    const omega = 2 / smoothTime;\r\n    const x = omega * deltaTime;\r\n    const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);\r\n    let change = current - target;\r\n    const originalTo = target;\r\n    // Clamp maximum speed\r\n    const maxChange = maxSpeed * smoothTime;\r\n    change = clamp(change, -maxChange, maxChange);\r\n    target = current - change;\r\n    const temp = (currentVelocityRef.value + omega * change) * deltaTime;\r\n    currentVelocityRef.value = (currentVelocityRef.value - omega * temp) * exp;\r\n    let output = target + (change + temp) * exp;\r\n    // Prevent overshooting\r\n    if (originalTo - current > 0.0 === output > originalTo) {\r\n        output = originalTo;\r\n        currentVelocityRef.value = (output - originalTo) / deltaTime;\r\n    }\r\n    return output;\r\n}\r\n// https://docs.unity3d.com/ScriptReference/Vector3.SmoothDamp.html\r\n// https://github.com/Unity-Technologies/UnityCsReference/blob/a2bdfe9b3c4cd4476f44bf52f848063bfaf7b6b9/Runtime/Export/Math/Vector3.cs#L97\r\nfunction smoothDampVec3(current, target, currentVelocityRef, smoothTime, maxSpeed = Infinity, deltaTime, out) {\r\n    // Based on Game Programming Gems 4 Chapter 1.10\r\n    smoothTime = Math.max(0.0001, smoothTime);\r\n    const omega = 2 / smoothTime;\r\n    const x = omega * deltaTime;\r\n    const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);\r\n    let targetX = target.x;\r\n    let targetY = target.y;\r\n    let targetZ = target.z;\r\n    let changeX = current.x - targetX;\r\n    let changeY = current.y - targetY;\r\n    let changeZ = current.z - targetZ;\r\n    const originalToX = targetX;\r\n    const originalToY = targetY;\r\n    const originalToZ = targetZ;\r\n    // Clamp maximum speed\r\n    const maxChange = maxSpeed * smoothTime;\r\n    const maxChangeSq = maxChange * maxChange;\r\n    const magnitudeSq = changeX * changeX + changeY * changeY + changeZ * changeZ;\r\n    if (magnitudeSq > maxChangeSq) {\r\n        const magnitude = Math.sqrt(magnitudeSq);\r\n        changeX = changeX / magnitude * maxChange;\r\n        changeY = changeY / magnitude * maxChange;\r\n        changeZ = changeZ / magnitude * maxChange;\r\n    }\r\n    targetX = current.x - changeX;\r\n    targetY = current.y - changeY;\r\n    targetZ = current.z - changeZ;\r\n    const tempX = (currentVelocityRef.x + omega * changeX) * deltaTime;\r\n    const tempY = (currentVelocityRef.y + omega * changeY) * deltaTime;\r\n    const tempZ = (currentVelocityRef.z + omega * changeZ) * deltaTime;\r\n    currentVelocityRef.x = (currentVelocityRef.x - omega * tempX) * exp;\r\n    currentVelocityRef.y = (currentVelocityRef.y - omega * tempY) * exp;\r\n    currentVelocityRef.z = (currentVelocityRef.z - omega * tempZ) * exp;\r\n    out.x = targetX + (changeX + tempX) * exp;\r\n    out.y = targetY + (changeY + tempY) * exp;\r\n    out.z = targetZ + (changeZ + tempZ) * exp;\r\n    // Prevent overshooting\r\n    const origMinusCurrentX = originalToX - current.x;\r\n    const origMinusCurrentY = originalToY - current.y;\r\n    const origMinusCurrentZ = originalToZ - current.z;\r\n    const outMinusOrigX = out.x - originalToX;\r\n    const outMinusOrigY = out.y - originalToY;\r\n    const outMinusOrigZ = out.z - originalToZ;\r\n    if (origMinusCurrentX * outMinusOrigX + origMinusCurrentY * outMinusOrigY + origMinusCurrentZ * outMinusOrigZ > 0) {\r\n        out.x = originalToX;\r\n        out.y = originalToY;\r\n        out.z = originalToZ;\r\n        currentVelocityRef.x = (out.x - originalToX) / deltaTime;\r\n        currentVelocityRef.y = (out.y - originalToY) / deltaTime;\r\n        currentVelocityRef.z = (out.z - originalToZ) / deltaTime;\r\n    }\r\n    return out;\r\n}\r\n\r\nfunction extractClientCoordFromEvent(pointers, out) {\r\n    out.set(0, 0);\r\n    pointers.forEach((pointer) => {\r\n        out.x += pointer.clientX;\r\n        out.y += pointer.clientY;\r\n    });\r\n    out.x /= pointers.length;\r\n    out.y /= pointers.length;\r\n}\r\n\r\nfunction notSupportedInOrthographicCamera(camera, message) {\r\n    if (isOrthographicCamera(camera)) {\r\n        console.warn(`${message} is not supported in OrthographicCamera`);\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nclass EventDispatcher {\r\n    constructor() {\r\n        this._listeners = {};\r\n    }\r\n    /**\r\n     * Adds the specified event listener.\r\n     * @param type event name\r\n     * @param listener handler function\r\n     * @category Methods\r\n     */\r\n    addEventListener(type, listener) {\r\n        const listeners = this._listeners;\r\n        if (listeners[type] === undefined)\r\n            listeners[type] = [];\r\n        if (listeners[type].indexOf(listener) === -1)\r\n            listeners[type].push(listener);\r\n    }\r\n    /**\r\n     * Presence of the specified event listener.\r\n     * @param type event name\r\n     * @param listener handler function\r\n     * @category Methods\r\n     */\r\n    hasEventListener(type, listener) {\r\n        const listeners = this._listeners;\r\n        return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;\r\n    }\r\n    /**\r\n     * Removes the specified event listener\r\n     * @param type event name\r\n     * @param listener handler function\r\n     * @category Methods\r\n     */\r\n    removeEventListener(type, listener) {\r\n        const listeners = this._listeners;\r\n        const listenerArray = listeners[type];\r\n        if (listenerArray !== undefined) {\r\n            const index = listenerArray.indexOf(listener);\r\n            if (index !== -1)\r\n                listenerArray.splice(index, 1);\r\n        }\r\n    }\r\n    /**\r\n     * Removes all event listeners\r\n     * @param type event name\r\n     * @category Methods\r\n     */\r\n    removeAllEventListeners(type) {\r\n        if (!type) {\r\n            this._listeners = {};\r\n            return;\r\n        }\r\n        if (Array.isArray(this._listeners[type]))\r\n            this._listeners[type].length = 0;\r\n    }\r\n    /**\r\n     * Fire an event type.\r\n     * @param event DispatcherEvent\r\n     * @category Methods\r\n     */\r\n    dispatchEvent(event) {\r\n        const listeners = this._listeners;\r\n        const listenerArray = listeners[event.type];\r\n        if (listenerArray !== undefined) {\r\n            event.target = this;\r\n            const array = listenerArray.slice(0);\r\n            for (let i = 0, l = array.length; i < l; i++) {\r\n                array[i].call(this, event);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nconst VERSION = '2.7.3'; // will be replaced with `version` in package.json during the build process.\r\nconst TOUCH_DOLLY_FACTOR = 1 / 8;\r\nconst isBrowser = typeof window !== 'undefined';\r\nconst isMac = isBrowser && /Mac/.test(navigator.platform);\r\nconst isPointerEventsNotSupported = !(isBrowser && 'PointerEvent' in window); // macOS Safari 12 does not support PointerEvents API\r\nlet THREE;\r\nlet _ORIGIN;\r\nlet _AXIS_Y;\r\nlet _AXIS_Z;\r\nlet _v2;\r\nlet _v3A;\r\nlet _v3B;\r\nlet _v3C;\r\nlet _cameraDirection;\r\nlet _xColumn;\r\nlet _yColumn;\r\nlet _zColumn;\r\nlet _deltaTarget;\r\nlet _deltaOffset;\r\nlet _sphericalA;\r\nlet _sphericalB;\r\nlet _box3A;\r\nlet _box3B;\r\nlet _sphere;\r\nlet _quaternionA;\r\nlet _quaternionB;\r\nlet _rotationMatrix;\r\nlet _raycaster;\r\nclass CameraControls extends EventDispatcher {\r\n    /**\r\n     * Injects THREE as the dependency. You can then proceed to use CameraControls.\r\n     *\r\n     * e.g\r\n     * ```javascript\r\n     * CameraControls.install( { THREE: THREE } );\r\n     * ```\r\n     *\r\n     * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.\r\n     *\r\n     * ```js\r\n     * import {\r\n     * \tVector2,\r\n     * \tVector3,\r\n     * \tVector4,\r\n     * \tQuaternion,\r\n     * \tMatrix4,\r\n     * \tSpherical,\r\n     * \tBox3,\r\n     * \tSphere,\r\n     * \tRaycaster,\r\n     * \tMathUtils,\r\n     * } from 'three';\r\n     *\r\n     * const subsetOfTHREE = {\r\n     * \tVector2   : Vector2,\r\n     * \tVector3   : Vector3,\r\n     * \tVector4   : Vector4,\r\n     * \tQuaternion: Quaternion,\r\n     * \tMatrix4   : Matrix4,\r\n     * \tSpherical : Spherical,\r\n     * \tBox3      : Box3,\r\n     * \tSphere    : Sphere,\r\n     * \tRaycaster : Raycaster,\r\n     * };\r\n\r\n     * CameraControls.install( { THREE: subsetOfTHREE } );\r\n     * ```\r\n     * @category Statics\r\n     */\r\n    static install(libs) {\r\n        THREE = libs.THREE;\r\n        _ORIGIN = Object.freeze(new THREE.Vector3(0, 0, 0));\r\n        _AXIS_Y = Object.freeze(new THREE.Vector3(0, 1, 0));\r\n        _AXIS_Z = Object.freeze(new THREE.Vector3(0, 0, 1));\r\n        _v2 = new THREE.Vector2();\r\n        _v3A = new THREE.Vector3();\r\n        _v3B = new THREE.Vector3();\r\n        _v3C = new THREE.Vector3();\r\n        _cameraDirection = new THREE.Vector3();\r\n        _xColumn = new THREE.Vector3();\r\n        _yColumn = new THREE.Vector3();\r\n        _zColumn = new THREE.Vector3();\r\n        _deltaTarget = new THREE.Vector3();\r\n        _deltaOffset = new THREE.Vector3();\r\n        _sphericalA = new THREE.Spherical();\r\n        _sphericalB = new THREE.Spherical();\r\n        _box3A = new THREE.Box3();\r\n        _box3B = new THREE.Box3();\r\n        _sphere = new THREE.Sphere();\r\n        _quaternionA = new THREE.Quaternion();\r\n        _quaternionB = new THREE.Quaternion();\r\n        _rotationMatrix = new THREE.Matrix4();\r\n        _raycaster = new THREE.Raycaster();\r\n    }\r\n    /**\r\n     * list all ACTIONs\r\n     * @category Statics\r\n     */\r\n    static get ACTION() {\r\n        return ACTION;\r\n    }\r\n    /**\r\n     * Creates a `CameraControls` instance.\r\n     *\r\n     * Note:\r\n     * You **must install** three.js before using camera-controls. see [#install](#install)\r\n     * Not doing so will lead to runtime errors (`undefined` references to THREE).\r\n     *\r\n     * e.g.\r\n     * ```\r\n     * CameraControls.install( { THREE } );\r\n     * const cameraControls = new CameraControls( camera, domElement );\r\n     * ```\r\n     *\r\n     * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.\r\n     * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.\r\n     * @category Constructor\r\n     */\r\n    constructor(camera, domElement) {\r\n        super();\r\n        /**\r\n         * Minimum vertical angle in radians.\r\n         * The angle has to be between `0` and `.maxPolarAngle` inclusive.\r\n         * The default value is `0`.\r\n         *\r\n         * e.g.\r\n         * ```\r\n         * cameraControls.maxPolarAngle = 0;\r\n         * ```\r\n         * @category Properties\r\n         */\r\n        this.minPolarAngle = 0; // radians\r\n        /**\r\n         * Maximum vertical angle in radians.\r\n         * The angle has to be between `.maxPolarAngle` and `Math.PI` inclusive.\r\n         * The default value is `Math.PI`.\r\n         *\r\n         * e.g.\r\n         * ```\r\n         * cameraControls.maxPolarAngle = Math.PI;\r\n         * ```\r\n         * @category Properties\r\n         */\r\n        this.maxPolarAngle = Math.PI; // radians\r\n        /**\r\n         * Minimum horizontal angle in radians.\r\n         * The angle has to be less than `.maxAzimuthAngle`.\r\n         * The default value is `- Infinity`.\r\n         *\r\n         * e.g.\r\n         * ```\r\n         * cameraControls.minAzimuthAngle = - Infinity;\r\n         * ```\r\n         * @category Properties\r\n         */\r\n        this.minAzimuthAngle = -Infinity; // radians\r\n        /**\r\n         * Maximum horizontal angle in radians.\r\n         * The angle has to be greater than `.minAzimuthAngle`.\r\n         * The default value is `Infinity`.\r\n         *\r\n         * e.g.\r\n         * ```\r\n         * cameraControls.maxAzimuthAngle = Infinity;\r\n         * ```\r\n         * @category Properties\r\n         */\r\n        this.maxAzimuthAngle = Infinity; // radians\r\n        // How far you can dolly in and out ( PerspectiveCamera only )\r\n        /**\r\n         * Minimum distance for dolly. The value must be higher than `0`. Default is `Number.EPSILON`.\r\n         * PerspectiveCamera only.\r\n         * @category Properties\r\n         */\r\n        this.minDistance = Number.EPSILON;\r\n        /**\r\n         * Maximum distance for dolly. The value must be higher than `minDistance`. Default is `Infinity`.\r\n         * PerspectiveCamera only.\r\n         * @category Properties\r\n         */\r\n        this.maxDistance = Infinity;\r\n        /**\r\n         * `true` to enable Infinity Dolly for wheel and pinch. Use this with `minDistance` and `maxDistance`\r\n         * If the Dolly distance is less (or over) than the `minDistance` (or `maxDistance`), `infinityDolly` will keep the distance and pushes the target position instead.\r\n         * @category Properties\r\n         */\r\n        this.infinityDolly = false;\r\n        /**\r\n         * Minimum camera zoom.\r\n         * @category Properties\r\n         */\r\n        this.minZoom = 0.01;\r\n        /**\r\n         * Maximum camera zoom.\r\n         * @category Properties\r\n         */\r\n        this.maxZoom = Infinity;\r\n        /**\r\n         * Approximate time in seconds to reach the target. A smaller value will reach the target faster.\r\n         * @category Properties\r\n         */\r\n        this.smoothTime = 0.25;\r\n        /**\r\n         * the smoothTime while dragging\r\n         * @category Properties\r\n         */\r\n        this.draggingSmoothTime = 0.125;\r\n        /**\r\n         * Max transition speed in unit-per-seconds\r\n         * @category Properties\r\n         */\r\n        this.maxSpeed = Infinity;\r\n        /**\r\n         * Speed of azimuth (horizontal) rotation.\r\n         * @category Properties\r\n         */\r\n        this.azimuthRotateSpeed = 1.0;\r\n        /**\r\n         * Speed of polar (vertical) rotation.\r\n         * @category Properties\r\n         */\r\n        this.polarRotateSpeed = 1.0;\r\n        /**\r\n         * Speed of mouse-wheel dollying.\r\n         * @category Properties\r\n         */\r\n        this.dollySpeed = 1.0;\r\n        /**\r\n         * `true` to invert direction when dollying or zooming via drag\r\n         * @category Properties\r\n         */\r\n        this.dollyDragInverted = false;\r\n        /**\r\n         * Speed of drag for truck and pedestal.\r\n         * @category Properties\r\n         */\r\n        this.truckSpeed = 2.0;\r\n        /**\r\n         * `true` to enable Dolly-in to the mouse cursor coords.\r\n         * @category Properties\r\n         */\r\n        this.dollyToCursor = false;\r\n        /**\r\n         * @category Properties\r\n         */\r\n        this.dragToOffset = false;\r\n        /**\r\n         * The same as `.screenSpacePanning` in three.js's OrbitControls.\r\n         * @category Properties\r\n         */\r\n        this.verticalDragToForward = false;\r\n        /**\r\n         * Friction ratio of the boundary.\r\n         * @category Properties\r\n         */\r\n        this.boundaryFriction = 0.0;\r\n        /**\r\n         * Controls how soon the `rest` event fires as the camera slows.\r\n         * @category Properties\r\n         */\r\n        this.restThreshold = 0.01;\r\n        /**\r\n         * An array of Meshes to collide with camera.\r\n         * Be aware colliderMeshes may decrease performance. The collision test uses 4 raycasters from the camera since the near plane has 4 corners.\r\n         * @category Properties\r\n         */\r\n        this.colliderMeshes = [];\r\n        /**\r\n         * Force cancel user dragging.\r\n         * @category Methods\r\n         */\r\n        // cancel will be overwritten in the constructor.\r\n        this.cancel = () => { };\r\n        this._enabled = true;\r\n        this._state = ACTION.NONE;\r\n        this._viewport = null;\r\n        this._changedDolly = 0;\r\n        this._changedZoom = 0;\r\n        this._hasRested = true;\r\n        this._boundaryEnclosesCamera = false;\r\n        this._needsUpdate = true;\r\n        this._updatedLastTime = false;\r\n        this._elementRect = new DOMRect();\r\n        this._isDragging = false;\r\n        this._dragNeedsUpdate = true;\r\n        this._activePointers = [];\r\n        this._lockedPointer = null;\r\n        this._interactiveArea = new DOMRect(0, 0, 1, 1);\r\n        // Use draggingSmoothTime over smoothTime while true.\r\n        // set automatically true on user-dragging start.\r\n        // set automatically false on programmable methods call.\r\n        this._isUserControllingRotate = false;\r\n        this._isUserControllingDolly = false;\r\n        this._isUserControllingTruck = false;\r\n        this._isUserControllingOffset = false;\r\n        this._isUserControllingZoom = false;\r\n        this._lastDollyDirection = DOLLY_DIRECTION.NONE;\r\n        // velocities for smoothDamp\r\n        this._thetaVelocity = { value: 0 };\r\n        this._phiVelocity = { value: 0 };\r\n        this._radiusVelocity = { value: 0 };\r\n        this._targetVelocity = new THREE.Vector3();\r\n        this._focalOffsetVelocity = new THREE.Vector3();\r\n        this._zoomVelocity = { value: 0 };\r\n        this._truckInternal = (deltaX, deltaY, dragToOffset) => {\r\n            let truckX;\r\n            let pedestalY;\r\n            if (isPerspectiveCamera(this._camera)) {\r\n                const offset = _v3A.copy(this._camera.position).sub(this._target);\r\n                // half of the fov is center to top of screen\r\n                const fov = this._camera.getEffectiveFOV() * DEG2RAD;\r\n                const targetDistance = offset.length() * Math.tan(fov * 0.5);\r\n                truckX = (this.truckSpeed * deltaX * targetDistance / this._elementRect.height);\r\n                pedestalY = (this.truckSpeed * deltaY * targetDistance / this._elementRect.height);\r\n            }\r\n            else if (isOrthographicCamera(this._camera)) {\r\n                const camera = this._camera;\r\n                truckX = deltaX * (camera.right - camera.left) / camera.zoom / this._elementRect.width;\r\n                pedestalY = deltaY * (camera.top - camera.bottom) / camera.zoom / this._elementRect.height;\r\n            }\r\n            else {\r\n                return;\r\n            }\r\n            if (this.verticalDragToForward) {\r\n                dragToOffset ?\r\n                    this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y, this._focalOffsetEnd.z, true) :\r\n                    this.truck(truckX, 0, true);\r\n                this.forward(-pedestalY, true);\r\n            }\r\n            else {\r\n                dragToOffset ?\r\n                    this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y + pedestalY, this._focalOffsetEnd.z, true) :\r\n                    this.truck(truckX, pedestalY, true);\r\n            }\r\n        };\r\n        this._rotateInternal = (deltaX, deltaY) => {\r\n            const theta = PI_2 * this.azimuthRotateSpeed * deltaX / this._elementRect.height; // divide by *height* to refer the resolution\r\n            const phi = PI_2 * this.polarRotateSpeed * deltaY / this._elementRect.height;\r\n            this.rotate(theta, phi, true);\r\n        };\r\n        this._dollyInternal = (delta, x, y) => {\r\n            const dollyScale = Math.pow(0.95, -delta * this.dollySpeed);\r\n            const lastDistance = this._sphericalEnd.radius;\r\n            const distance = this._sphericalEnd.radius * dollyScale;\r\n            const clampedDistance = clamp(distance, this.minDistance, this.maxDistance);\r\n            const overflowedDistance = clampedDistance - distance;\r\n            if (this.infinityDolly && this.dollyToCursor) {\r\n                this._dollyToNoClamp(distance, true);\r\n            }\r\n            else if (this.infinityDolly && !this.dollyToCursor) {\r\n                this.dollyInFixed(overflowedDistance, true);\r\n                this._dollyToNoClamp(clampedDistance, true);\r\n            }\r\n            else {\r\n                this._dollyToNoClamp(clampedDistance, true);\r\n            }\r\n            if (this.dollyToCursor) {\r\n                this._changedDolly += (this.infinityDolly ? distance : clampedDistance) - lastDistance;\r\n                this._dollyControlCoord.set(x, y);\r\n            }\r\n            this._lastDollyDirection = Math.sign(-delta);\r\n        };\r\n        this._zoomInternal = (delta, x, y) => {\r\n            const zoomScale = Math.pow(0.95, delta * this.dollySpeed);\r\n            const lastZoom = this._zoom;\r\n            const zoom = this._zoom * zoomScale;\r\n            // for both PerspectiveCamera and OrthographicCamera\r\n            this.zoomTo(zoom, true);\r\n            if (this.dollyToCursor) {\r\n                this._changedZoom += zoom - lastZoom;\r\n                this._dollyControlCoord.set(x, y);\r\n            }\r\n        };\r\n        // Check if the user has installed THREE\r\n        if (typeof THREE === 'undefined') {\r\n            console.error('camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information.');\r\n        }\r\n        this._camera = camera;\r\n        this._yAxisUpSpace = new THREE.Quaternion().setFromUnitVectors(this._camera.up, _AXIS_Y);\r\n        this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert();\r\n        this._state = ACTION.NONE;\r\n        // the location\r\n        this._target = new THREE.Vector3();\r\n        this._targetEnd = this._target.clone();\r\n        this._focalOffset = new THREE.Vector3();\r\n        this._focalOffsetEnd = this._focalOffset.clone();\r\n        // rotation\r\n        this._spherical = new THREE.Spherical().setFromVector3(_v3A.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace));\r\n        this._sphericalEnd = this._spherical.clone();\r\n        this._lastDistance = this._spherical.radius;\r\n        this._zoom = this._camera.zoom;\r\n        this._zoomEnd = this._zoom;\r\n        this._lastZoom = this._zoom;\r\n        // collisionTest uses nearPlane.s\r\n        this._nearPlaneCorners = [\r\n            new THREE.Vector3(),\r\n            new THREE.Vector3(),\r\n            new THREE.Vector3(),\r\n            new THREE.Vector3(),\r\n        ];\r\n        this._updateNearPlaneCorners();\r\n        // Target cannot move outside of this box\r\n        this._boundary = new THREE.Box3(new THREE.Vector3(-Infinity, -Infinity, -Infinity), new THREE.Vector3(Infinity, Infinity, Infinity));\r\n        // reset\r\n        this._cameraUp0 = this._camera.up.clone();\r\n        this._target0 = this._target.clone();\r\n        this._position0 = this._camera.position.clone();\r\n        this._zoom0 = this._zoom;\r\n        this._focalOffset0 = this._focalOffset.clone();\r\n        this._dollyControlCoord = new THREE.Vector2();\r\n        // configs\r\n        this.mouseButtons = {\r\n            left: ACTION.ROTATE,\r\n            middle: ACTION.DOLLY,\r\n            right: ACTION.TRUCK,\r\n            wheel: isPerspectiveCamera(this._camera) ? ACTION.DOLLY :\r\n                isOrthographicCamera(this._camera) ? ACTION.ZOOM :\r\n                    ACTION.NONE,\r\n        };\r\n        this.touches = {\r\n            one: ACTION.TOUCH_ROTATE,\r\n            two: isPerspectiveCamera(this._camera) ? ACTION.TOUCH_DOLLY_TRUCK :\r\n                isOrthographicCamera(this._camera) ? ACTION.TOUCH_ZOOM_TRUCK :\r\n                    ACTION.NONE,\r\n            three: ACTION.TOUCH_TRUCK,\r\n        };\r\n        const dragStartPosition = new THREE.Vector2();\r\n        const lastDragPosition = new THREE.Vector2();\r\n        const dollyStart = new THREE.Vector2();\r\n        const onPointerDown = (event) => {\r\n            if (!this._enabled || !this._domElement)\r\n                return;\r\n            if (this._interactiveArea.left !== 0 ||\r\n                this._interactiveArea.top !== 0 ||\r\n                this._interactiveArea.width !== 1 ||\r\n                this._interactiveArea.height !== 1) {\r\n                const elRect = this._domElement.getBoundingClientRect();\r\n                const left = event.clientX / elRect.width;\r\n                const top = event.clientY / elRect.height;\r\n                // check if the interactiveArea contains the drag start position.\r\n                if (left < this._interactiveArea.left ||\r\n                    left > this._interactiveArea.right ||\r\n                    top < this._interactiveArea.top ||\r\n                    top > this._interactiveArea.bottom)\r\n                    return;\r\n            }\r\n            // Don't call `event.preventDefault()` on the pointerdown event\r\n            // to keep receiving pointermove evens outside dragging iframe\r\n            // https://taye.me/blog/tips/2015/11/16/mouse-drag-outside-iframe/\r\n            const mouseButton = event.pointerType !== 'mouse' ? null :\r\n                (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT ? MOUSE_BUTTON.LEFT :\r\n                    (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE ? MOUSE_BUTTON.MIDDLE :\r\n                        (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT ? MOUSE_BUTTON.RIGHT :\r\n                            null;\r\n            if (mouseButton !== null) {\r\n                const zombiePointer = this._findPointerByMouseButton(mouseButton);\r\n                zombiePointer && this._disposePointer(zombiePointer);\r\n            }\r\n            if ((event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT && this._lockedPointer)\r\n                return;\r\n            const pointer = {\r\n                pointerId: event.pointerId,\r\n                clientX: event.clientX,\r\n                clientY: event.clientY,\r\n                deltaX: 0,\r\n                deltaY: 0,\r\n                mouseButton,\r\n            };\r\n            this._activePointers.push(pointer);\r\n            // eslint-disable-next-line no-undef\r\n            this._domElement.ownerDocument.removeEventListener('pointermove', onPointerMove, { passive: false });\r\n            this._domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);\r\n            this._domElement.ownerDocument.addEventListener('pointermove', onPointerMove, { passive: false });\r\n            this._domElement.ownerDocument.addEventListener('pointerup', onPointerUp);\r\n            this._isDragging = true;\r\n            startDragging(event);\r\n        };\r\n        const onMouseDown = (event) => {\r\n            if (!this._enabled || !this._domElement || this._lockedPointer)\r\n                return;\r\n            if (this._interactiveArea.left !== 0 ||\r\n                this._interactiveArea.top !== 0 ||\r\n                this._interactiveArea.width !== 1 ||\r\n                this._interactiveArea.height !== 1) {\r\n                const elRect = this._domElement.getBoundingClientRect();\r\n                const left = event.clientX / elRect.width;\r\n                const top = event.clientY / elRect.height;\r\n                // check if the interactiveArea contains the drag start position.\r\n                if (left < this._interactiveArea.left ||\r\n                    left > this._interactiveArea.right ||\r\n                    top < this._interactiveArea.top ||\r\n                    top > this._interactiveArea.bottom)\r\n                    return;\r\n            }\r\n            const mouseButton = (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT ? MOUSE_BUTTON.LEFT :\r\n                (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE ? MOUSE_BUTTON.MIDDLE :\r\n                    (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT ? MOUSE_BUTTON.RIGHT :\r\n                        null;\r\n            if (mouseButton !== null) {\r\n                const zombiePointer = this._findPointerByMouseButton(mouseButton);\r\n                zombiePointer && this._disposePointer(zombiePointer);\r\n            }\r\n            const pointer = {\r\n                pointerId: 1,\r\n                clientX: event.clientX,\r\n                clientY: event.clientY,\r\n                deltaX: 0,\r\n                deltaY: 0,\r\n                mouseButton: (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT ? MOUSE_BUTTON.LEFT :\r\n                    (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.LEFT ? MOUSE_BUTTON.MIDDLE :\r\n                        (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.LEFT ? MOUSE_BUTTON.RIGHT :\r\n                            null,\r\n            };\r\n            this._activePointers.push(pointer);\r\n            // see https://github.com/microsoft/TypeScript/issues/32912#issuecomment-522142969\r\n            // eslint-disable-next-line no-undef\r\n            this._domElement.ownerDocument.removeEventListener('mousemove', onMouseMove);\r\n            this._domElement.ownerDocument.removeEventListener('mouseup', onMouseUp);\r\n            this._domElement.ownerDocument.addEventListener('mousemove', onMouseMove);\r\n            this._domElement.ownerDocument.addEventListener('mouseup', onMouseUp);\r\n            this._isDragging = true;\r\n            startDragging(event);\r\n        };\r\n        const onPointerMove = (event) => {\r\n            if (event.cancelable)\r\n                event.preventDefault();\r\n            const pointerId = event.pointerId;\r\n            const pointer = this._lockedPointer || this._findPointerById(pointerId);\r\n            if (!pointer)\r\n                return;\r\n            pointer.clientX = event.clientX;\r\n            pointer.clientY = event.clientY;\r\n            pointer.deltaX = event.movementX;\r\n            pointer.deltaY = event.movementY;\r\n            this._state = 0;\r\n            if (event.pointerType === 'touch') {\r\n                switch (this._activePointers.length) {\r\n                    case 1:\r\n                        this._state = this.touches.one;\r\n                        break;\r\n                    case 2:\r\n                        this._state = this.touches.two;\r\n                        break;\r\n                    case 3:\r\n                        this._state = this.touches.three;\r\n                        break;\r\n                }\r\n            }\r\n            else {\r\n                if ((!this._isDragging && this._lockedPointer) ||\r\n                    this._isDragging && (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {\r\n                    this._state = this._state | this.mouseButtons.left;\r\n                }\r\n                if (this._isDragging && (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {\r\n                    this._state = this._state | this.mouseButtons.middle;\r\n                }\r\n                if (this._isDragging && (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {\r\n                    this._state = this._state | this.mouseButtons.right;\r\n                }\r\n            }\r\n            dragging();\r\n        };\r\n        const onMouseMove = (event) => {\r\n            const pointer = this._lockedPointer || this._findPointerById(1);\r\n            if (!pointer)\r\n                return;\r\n            pointer.clientX = event.clientX;\r\n            pointer.clientY = event.clientY;\r\n            pointer.deltaX = event.movementX;\r\n            pointer.deltaY = event.movementY;\r\n            this._state = 0;\r\n            if (this._lockedPointer ||\r\n                (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {\r\n                this._state = this._state | this.mouseButtons.left;\r\n            }\r\n            if ((event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {\r\n                this._state = this._state | this.mouseButtons.middle;\r\n            }\r\n            if ((event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {\r\n                this._state = this._state | this.mouseButtons.right;\r\n            }\r\n            dragging();\r\n        };\r\n        const onPointerUp = (event) => {\r\n            const pointer = this._findPointerById(event.pointerId);\r\n            if (pointer && pointer === this._lockedPointer)\r\n                return;\r\n            pointer && this._disposePointer(pointer);\r\n            if (event.pointerType === 'touch') {\r\n                switch (this._activePointers.length) {\r\n                    case 0:\r\n                        this._state = ACTION.NONE;\r\n                        break;\r\n                    case 1:\r\n                        this._state = this.touches.one;\r\n                        break;\r\n                    case 2:\r\n                        this._state = this.touches.two;\r\n                        break;\r\n                    case 3:\r\n                        this._state = this.touches.three;\r\n                        break;\r\n                }\r\n            }\r\n            else {\r\n                this._state = ACTION.NONE;\r\n            }\r\n            endDragging();\r\n        };\r\n        const onMouseUp = () => {\r\n            const pointer = this._findPointerById(1);\r\n            if (pointer && pointer === this._lockedPointer)\r\n                return;\r\n            pointer && this._disposePointer(pointer);\r\n            this._state = ACTION.NONE;\r\n            endDragging();\r\n        };\r\n        let lastScrollTimeStamp = -1;\r\n        const onMouseWheel = (event) => {\r\n            if (!this._domElement)\r\n                return;\r\n            if (!this._enabled || this.mouseButtons.wheel === ACTION.NONE)\r\n                return;\r\n            if (this._interactiveArea.left !== 0 ||\r\n                this._interactiveArea.top !== 0 ||\r\n                this._interactiveArea.width !== 1 ||\r\n                this._interactiveArea.height !== 1) {\r\n                const elRect = this._domElement.getBoundingClientRect();\r\n                const left = event.clientX / elRect.width;\r\n                const top = event.clientY / elRect.height;\r\n                // check if the interactiveArea contains the drag start position.\r\n                if (left < this._interactiveArea.left ||\r\n                    left > this._interactiveArea.right ||\r\n                    top < this._interactiveArea.top ||\r\n                    top > this._interactiveArea.bottom)\r\n                    return;\r\n            }\r\n            event.preventDefault();\r\n            if (this.dollyToCursor ||\r\n                this.mouseButtons.wheel === ACTION.ROTATE ||\r\n                this.mouseButtons.wheel === ACTION.TRUCK) {\r\n                const now = performance.now();\r\n                // only need to fire this at scroll start.\r\n                if (lastScrollTimeStamp - now < 1000)\r\n                    this._getClientRect(this._elementRect);\r\n                lastScrollTimeStamp = now;\r\n            }\r\n            // Ref: https://github.com/cedricpinson/osgjs/blob/00e5a7e9d9206c06fdde0436e1d62ab7cb5ce853/sources/osgViewer/input/source/InputSourceMouse.js#L89-L103\r\n            const deltaYFactor = isMac ? -1 : -3;\r\n            const delta = (event.deltaMode === 1) ? event.deltaY / deltaYFactor : event.deltaY / (deltaYFactor * 10);\r\n            const x = this.dollyToCursor ? (event.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;\r\n            const y = this.dollyToCursor ? (event.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;\r\n            switch (this.mouseButtons.wheel) {\r\n                case ACTION.ROTATE: {\r\n                    this._rotateInternal(event.deltaX, event.deltaY);\r\n                    this._isUserControllingRotate = true;\r\n                    break;\r\n                }\r\n                case ACTION.TRUCK: {\r\n                    this._truckInternal(event.deltaX, event.deltaY, false);\r\n                    this._isUserControllingTruck = true;\r\n                    break;\r\n                }\r\n                case ACTION.OFFSET: {\r\n                    this._truckInternal(event.deltaX, event.deltaY, true);\r\n                    this._isUserControllingOffset = true;\r\n                    break;\r\n                }\r\n                case ACTION.DOLLY: {\r\n                    this._dollyInternal(-delta, x, y);\r\n                    this._isUserControllingDolly = true;\r\n                    break;\r\n                }\r\n                case ACTION.ZOOM: {\r\n                    this._zoomInternal(-delta, x, y);\r\n                    this._isUserControllingZoom = true;\r\n                    break;\r\n                }\r\n            }\r\n            this.dispatchEvent({ type: 'control' });\r\n        };\r\n        const onContextMenu = (event) => {\r\n            if (!this._domElement || !this._enabled)\r\n                return;\r\n            // contextmenu event is fired right after pointerdown/mousedown.\r\n            // remove attached handlers and active pointer, if interrupted by contextmenu.\r\n            if (this.mouseButtons.right === CameraControls.ACTION.NONE) {\r\n                const pointerId = event instanceof PointerEvent ? event.pointerId :\r\n                    event instanceof MouseEvent ? 0 :\r\n                        0;\r\n                const pointer = this._findPointerById(pointerId);\r\n                pointer && this._disposePointer(pointer);\r\n                // eslint-disable-next-line no-undef\r\n                this._domElement.ownerDocument.removeEventListener('pointermove', onPointerMove, { passive: false });\r\n                this._domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);\r\n                this._domElement.ownerDocument.removeEventListener('mousemove', onMouseMove);\r\n                this._domElement.ownerDocument.removeEventListener('mouseup', onMouseUp);\r\n                return;\r\n            }\r\n            event.preventDefault();\r\n        };\r\n        const startDragging = (event) => {\r\n            if (!this._enabled)\r\n                return;\r\n            extractClientCoordFromEvent(this._activePointers, _v2);\r\n            this._getClientRect(this._elementRect);\r\n            dragStartPosition.copy(_v2);\r\n            lastDragPosition.copy(_v2);\r\n            const isMultiTouch = this._activePointers.length >= 2;\r\n            if (isMultiTouch) {\r\n                // 2 finger pinch\r\n                const dx = _v2.x - this._activePointers[1].clientX;\r\n                const dy = _v2.y - this._activePointers[1].clientY;\r\n                const distance = Math.sqrt(dx * dx + dy * dy);\r\n                dollyStart.set(0, distance);\r\n                // center coords of 2 finger truck\r\n                const x = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5;\r\n                const y = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;\r\n                lastDragPosition.set(x, y);\r\n            }\r\n            this._state = 0;\r\n            if (!event) {\r\n                if (this._lockedPointer)\r\n                    this._state = this._state | this.mouseButtons.left;\r\n            }\r\n            else if ('pointerType' in event && event.pointerType === 'touch') {\r\n                switch (this._activePointers.length) {\r\n                    case 1:\r\n                        this._state = this.touches.one;\r\n                        break;\r\n                    case 2:\r\n                        this._state = this.touches.two;\r\n                        break;\r\n                    case 3:\r\n                        this._state = this.touches.three;\r\n                        break;\r\n                }\r\n            }\r\n            else {\r\n                if (!this._lockedPointer && (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {\r\n                    this._state = this._state | this.mouseButtons.left;\r\n                }\r\n                if ((event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {\r\n                    this._state = this._state | this.mouseButtons.middle;\r\n                }\r\n                if ((event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {\r\n                    this._state = this._state | this.mouseButtons.right;\r\n                }\r\n            }\r\n            // stop current movement on drag start\r\n            if ((this._state & ACTION.ROTATE) === ACTION.ROTATE ||\r\n                (this._state & ACTION.TOUCH_ROTATE) === ACTION.TOUCH_ROTATE ||\r\n                (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE ||\r\n                (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {\r\n                this._sphericalEnd.theta = this._spherical.theta;\r\n                this._sphericalEnd.phi = this._spherical.phi;\r\n                this._thetaVelocity.value = 0;\r\n                this._phiVelocity.value = 0;\r\n            }\r\n            if ((this._state & ACTION.TRUCK) === ACTION.TRUCK ||\r\n                (this._state & ACTION.TOUCH_TRUCK) === ACTION.TOUCH_TRUCK ||\r\n                (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK ||\r\n                (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK) {\r\n                this._targetEnd.copy(this._target);\r\n                this._targetVelocity.set(0, 0, 0);\r\n            }\r\n            if ((this._state & ACTION.DOLLY) === ACTION.DOLLY ||\r\n                (this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY ||\r\n                (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK ||\r\n                (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET ||\r\n                (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE) {\r\n                this._sphericalEnd.radius = this._spherical.radius;\r\n                this._radiusVelocity.value = 0;\r\n            }\r\n            if ((this._state & ACTION.ZOOM) === ACTION.ZOOM ||\r\n                (this._state & ACTION.TOUCH_ZOOM) === ACTION.TOUCH_ZOOM ||\r\n                (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK ||\r\n                (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET ||\r\n                (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {\r\n                this._zoomEnd = this._zoom;\r\n                this._zoomVelocity.value = 0;\r\n            }\r\n            if ((this._state & ACTION.OFFSET) === ACTION.OFFSET ||\r\n                (this._state & ACTION.TOUCH_OFFSET) === ACTION.TOUCH_OFFSET ||\r\n                (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET ||\r\n                (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET) {\r\n                this._focalOffsetEnd.copy(this._focalOffset);\r\n                this._focalOffsetVelocity.set(0, 0, 0);\r\n            }\r\n            this.dispatchEvent({ type: 'controlstart' });\r\n        };\r\n        const dragging = () => {\r\n            if (!this._enabled || !this._dragNeedsUpdate)\r\n                return;\r\n            this._dragNeedsUpdate = false;\r\n            extractClientCoordFromEvent(this._activePointers, _v2);\r\n            // When pointer lock is enabled clientX, clientY, screenX, and screenY remain 0.\r\n            // If pointer lock is enabled, use the Delta directory, and assume active-pointer is not multiple.\r\n            const isPointerLockActive = this._domElement && document.pointerLockElement === this._domElement;\r\n            const lockedPointer = isPointerLockActive ? this._lockedPointer || this._activePointers[0] : null;\r\n            const deltaX = lockedPointer ? -lockedPointer.deltaX : lastDragPosition.x - _v2.x;\r\n            const deltaY = lockedPointer ? -lockedPointer.deltaY : lastDragPosition.y - _v2.y;\r\n            lastDragPosition.copy(_v2);\r\n            if ((this._state & ACTION.ROTATE) === ACTION.ROTATE ||\r\n                (this._state & ACTION.TOUCH_ROTATE) === ACTION.TOUCH_ROTATE ||\r\n                (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE ||\r\n                (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {\r\n                this._rotateInternal(deltaX, deltaY);\r\n                this._isUserControllingRotate = true;\r\n            }\r\n            if ((this._state & ACTION.DOLLY) === ACTION.DOLLY ||\r\n                (this._state & ACTION.ZOOM) === ACTION.ZOOM) {\r\n                const dollyX = this.dollyToCursor ? (dragStartPosition.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;\r\n                const dollyY = this.dollyToCursor ? (dragStartPosition.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;\r\n                const dollyDirection = this.dollyDragInverted ? -1 : 1;\r\n                if ((this._state & ACTION.DOLLY) === ACTION.DOLLY) {\r\n                    this._dollyInternal(dollyDirection * deltaY * TOUCH_DOLLY_FACTOR, dollyX, dollyY);\r\n                    this._isUserControllingDolly = true;\r\n                }\r\n                else {\r\n                    this._zoomInternal(dollyDirection * deltaY * TOUCH_DOLLY_FACTOR, dollyX, dollyY);\r\n                    this._isUserControllingZoom = true;\r\n                }\r\n            }\r\n            if ((this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY ||\r\n                (this._state & ACTION.TOUCH_ZOOM) === ACTION.TOUCH_ZOOM ||\r\n                (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK ||\r\n                (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK ||\r\n                (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET ||\r\n                (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET ||\r\n                (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE ||\r\n                (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {\r\n                const dx = _v2.x - this._activePointers[1].clientX;\r\n                const dy = _v2.y - this._activePointers[1].clientY;\r\n                const distance = Math.sqrt(dx * dx + dy * dy);\r\n                const dollyDelta = dollyStart.y - distance;\r\n                dollyStart.set(0, distance);\r\n                const dollyX = this.dollyToCursor ? (lastDragPosition.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;\r\n                const dollyY = this.dollyToCursor ? (lastDragPosition.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;\r\n                if ((this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY ||\r\n                    (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE ||\r\n                    (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK ||\r\n                    (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET) {\r\n                    this._dollyInternal(dollyDelta * TOUCH_DOLLY_FACTOR, dollyX, dollyY);\r\n                    this._isUserControllingDolly = true;\r\n                }\r\n                else {\r\n                    this._zoomInternal(dollyDelta * TOUCH_DOLLY_FACTOR, dollyX, dollyY);\r\n                    this._isUserControllingZoom = true;\r\n                }\r\n            }\r\n            if ((this._state & ACTION.TRUCK) === ACTION.TRUCK ||\r\n                (this._state & ACTION.TOUCH_TRUCK) === ACTION.TOUCH_TRUCK ||\r\n                (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK ||\r\n                (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK) {\r\n                this._truckInternal(deltaX, deltaY, false);\r\n                this._isUserControllingTruck = true;\r\n            }\r\n            if ((this._state & ACTION.OFFSET) === ACTION.OFFSET ||\r\n                (this._state & ACTION.TOUCH_OFFSET) === ACTION.TOUCH_OFFSET ||\r\n                (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET ||\r\n                (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET) {\r\n                this._truckInternal(deltaX, deltaY, true);\r\n                this._isUserControllingOffset = true;\r\n            }\r\n            this.dispatchEvent({ type: 'control' });\r\n        };\r\n        const endDragging = () => {\r\n            extractClientCoordFromEvent(this._activePointers, _v2);\r\n            lastDragPosition.copy(_v2);\r\n            this._dragNeedsUpdate = false;\r\n            if (this._activePointers.length === 0 ||\r\n                (this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer)) {\r\n                this._isDragging = false;\r\n            }\r\n            if (this._activePointers.length === 0 && this._domElement) {\r\n                // eslint-disable-next-line no-undef\r\n                this._domElement.ownerDocument.removeEventListener('pointermove', onPointerMove, { passive: false });\r\n                this._domElement.ownerDocument.removeEventListener('mousemove', onMouseMove);\r\n                this._domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);\r\n                this._domElement.ownerDocument.removeEventListener('mouseup', onMouseUp);\r\n                this.dispatchEvent({ type: 'controlend' });\r\n            }\r\n        };\r\n        this.lockPointer = () => {\r\n            if (!this._enabled || !this._domElement)\r\n                return;\r\n            this.cancel();\r\n            // Element.requestPointerLock is allowed to happen without any pointer active - create a faux one for compatibility with controls\r\n            this._lockedPointer = {\r\n                pointerId: -1,\r\n                clientX: 0,\r\n                clientY: 0,\r\n                deltaX: 0,\r\n                deltaY: 0,\r\n                mouseButton: null,\r\n            };\r\n            this._activePointers.push(this._lockedPointer);\r\n            // eslint-disable-next-line no-undef\r\n            this._domElement.ownerDocument.removeEventListener('pointermove', onPointerMove, { passive: false });\r\n            this._domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);\r\n            this._domElement.requestPointerLock();\r\n            this._domElement.ownerDocument.addEventListener('pointerlockchange', onPointerLockChange);\r\n            this._domElement.ownerDocument.addEventListener('pointerlockerror', onPointerLockError);\r\n            this._domElement.ownerDocument.addEventListener('pointermove', onPointerMove, { passive: false });\r\n            this._domElement.ownerDocument.addEventListener('pointerup', onPointerUp);\r\n            startDragging();\r\n        };\r\n        this.unlockPointer = () => {\r\n            if (this._lockedPointer !== null) {\r\n                this._disposePointer(this._lockedPointer);\r\n                this._lockedPointer = null;\r\n            }\r\n            document.exitPointerLock();\r\n            this.cancel();\r\n            if (!this._domElement)\r\n                return;\r\n            this._domElement.ownerDocument.removeEventListener('pointerlockchange', onPointerLockChange);\r\n            this._domElement.ownerDocument.removeEventListener('pointerlockerror', onPointerLockError);\r\n        };\r\n        const onPointerLockChange = () => {\r\n            const isPointerLockActive = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement;\r\n            if (!isPointerLockActive)\r\n                this.unlockPointer();\r\n        };\r\n        const onPointerLockError = () => {\r\n            this.unlockPointer();\r\n        };\r\n        this._addAllEventListeners = (domElement) => {\r\n            this._domElement = domElement;\r\n            this._domElement.style.touchAction = 'none';\r\n            this._domElement.style.userSelect = 'none';\r\n            this._domElement.style.webkitUserSelect = 'none';\r\n            this._domElement.addEventListener('pointerdown', onPointerDown);\r\n            isPointerEventsNotSupported && this._domElement.addEventListener('mousedown', onMouseDown);\r\n            this._domElement.addEventListener('pointercancel', onPointerUp);\r\n            this._domElement.addEventListener('wheel', onMouseWheel, { passive: false });\r\n            this._domElement.addEventListener('contextmenu', onContextMenu);\r\n        };\r\n        this._removeAllEventListeners = () => {\r\n            if (!this._domElement)\r\n                return;\r\n            this._domElement.style.touchAction = '';\r\n            this._domElement.style.userSelect = '';\r\n            this._domElement.style.webkitUserSelect = '';\r\n            this._domElement.removeEventListener('pointerdown', onPointerDown);\r\n            this._domElement.removeEventListener('mousedown', onMouseDown);\r\n            this._domElement.removeEventListener('pointercancel', onPointerUp);\r\n            // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener#matching_event_listeners_for_removal\r\n            // > it's probably wise to use the same values used for the call to `addEventListener()` when calling `removeEventListener()`\r\n            // see https://github.com/microsoft/TypeScript/issues/32912#issuecomment-522142969\r\n            // eslint-disable-next-line no-undef\r\n            this._domElement.removeEventListener('wheel', onMouseWheel, { passive: false });\r\n            this._domElement.removeEventListener('contextmenu', onContextMenu);\r\n            // eslint-disable-next-line no-undef\r\n            this._domElement.ownerDocument.removeEventListener('pointermove', onPointerMove, { passive: false });\r\n            this._domElement.ownerDocument.removeEventListener('mousemove', onMouseMove);\r\n            this._domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);\r\n            this._domElement.ownerDocument.removeEventListener('mouseup', onMouseUp);\r\n            this._domElement.ownerDocument.removeEventListener('pointerlockchange', onPointerLockChange);\r\n            this._domElement.ownerDocument.removeEventListener('pointerlockerror', onPointerLockError);\r\n        };\r\n        this.cancel = () => {\r\n            if (this._state === ACTION.NONE)\r\n                return;\r\n            this._state = ACTION.NONE;\r\n            this._activePointers.length = 0;\r\n            endDragging();\r\n        };\r\n        if (domElement)\r\n            this.connect(domElement);\r\n        this.update(0);\r\n    }\r\n    /**\r\n     * The camera to be controlled\r\n     * @category Properties\r\n     */\r\n    get camera() {\r\n        return this._camera;\r\n    }\r\n    set camera(camera) {\r\n        this._camera = camera;\r\n        this.updateCameraUp();\r\n        this._camera.updateProjectionMatrix();\r\n        this._updateNearPlaneCorners();\r\n        this._needsUpdate = true;\r\n    }\r\n    /**\r\n     * Whether or not the controls are enabled.\r\n     * `false` to disable user dragging/touch-move, but all methods works.\r\n     * @category Properties\r\n     */\r\n    get enabled() {\r\n        return this._enabled;\r\n    }\r\n    set enabled(enabled) {\r\n        this._enabled = enabled;\r\n        if (!this._domElement)\r\n            return;\r\n        if (enabled) {\r\n            this._domElement.style.touchAction = 'none';\r\n            this._domElement.style.userSelect = 'none';\r\n            this._domElement.style.webkitUserSelect = 'none';\r\n        }\r\n        else {\r\n            this.cancel();\r\n            this._domElement.style.touchAction = '';\r\n            this._domElement.style.userSelect = '';\r\n            this._domElement.style.webkitUserSelect = '';\r\n        }\r\n    }\r\n    /**\r\n     * Returns `true` if the controls are active updating.\r\n     * readonly value.\r\n     * @category Properties\r\n     */\r\n    get active() {\r\n        return !this._hasRested;\r\n    }\r\n    /**\r\n     * Getter for the current `ACTION`.\r\n     * readonly value.\r\n     * @category Properties\r\n     */\r\n    get currentAction() {\r\n        return this._state;\r\n    }\r\n    /**\r\n     * get/set Current distance.\r\n     * @category Properties\r\n     */\r\n    get distance() {\r\n        return this._spherical.radius;\r\n    }\r\n    set distance(distance) {\r\n        if (this._spherical.radius === distance &&\r\n            this._sphericalEnd.radius === distance)\r\n            return;\r\n        this._spherical.radius = distance;\r\n        this._sphericalEnd.radius = distance;\r\n        this._needsUpdate = true;\r\n    }\r\n    // horizontal angle\r\n    /**\r\n     * get/set the azimuth angle (horizontal) in radians.\r\n     * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.\r\n     * @category Properties\r\n     */\r\n    get azimuthAngle() {\r\n        return this._spherical.theta;\r\n    }\r\n    set azimuthAngle(azimuthAngle) {\r\n        if (this._spherical.theta === azimuthAngle &&\r\n            this._sphericalEnd.theta === azimuthAngle)\r\n            return;\r\n        this._spherical.theta = azimuthAngle;\r\n        this._sphericalEnd.theta = azimuthAngle;\r\n        this._needsUpdate = true;\r\n    }\r\n    // vertical angle\r\n    /**\r\n     * get/set the polar angle (vertical) in radians.\r\n     * @category Properties\r\n     */\r\n    get polarAngle() {\r\n        return this._spherical.phi;\r\n    }\r\n    set polarAngle(polarAngle) {\r\n        if (this._spherical.phi === polarAngle &&\r\n            this._sphericalEnd.phi === polarAngle)\r\n            return;\r\n        this._spherical.phi = polarAngle;\r\n        this._sphericalEnd.phi = polarAngle;\r\n        this._needsUpdate = true;\r\n    }\r\n    /**\r\n     * Whether camera position should be enclosed in the boundary or not.\r\n     * @category Properties\r\n     */\r\n    get boundaryEnclosesCamera() {\r\n        return this._boundaryEnclosesCamera;\r\n    }\r\n    set boundaryEnclosesCamera(boundaryEnclosesCamera) {\r\n        this._boundaryEnclosesCamera = boundaryEnclosesCamera;\r\n        this._needsUpdate = true;\r\n    }\r\n    /**\r\n     * Set drag-start, touches and wheel enable area in the domElement.\r\n     * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.\r\n     * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.\r\n     * @category Properties\r\n     */\r\n    set interactiveArea(interactiveArea) {\r\n        this._interactiveArea.width = clamp(interactiveArea.width, 0, 1);\r\n        this._interactiveArea.height = clamp(interactiveArea.height, 0, 1);\r\n        this._interactiveArea.x = clamp(interactiveArea.x, 0, 1 - this._interactiveArea.width);\r\n        this._interactiveArea.y = clamp(interactiveArea.y, 0, 1 - this._interactiveArea.height);\r\n    }\r\n    /**\r\n     * Adds the specified event listener.\r\n     * Applicable event types (which is `K`) are:\r\n     * | Event name          | Timing |\r\n     * | ------------------- | ------ |\r\n     * | `'controlstart'`    | When the user starts to control the camera via mouse / touches. ¹ |\r\n     * | `'control'`         | When the user controls the camera (dragging). |\r\n     * | `'controlend'`      | When the user ends to control the camera. ¹ |\r\n     * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |\r\n     * | `'update'`          | When the camera position is updated. |\r\n     * | `'wake'`            | When the camera starts moving. |\r\n     * | `'rest'`            | When the camera movement is below `.restThreshold` ². |\r\n     * | `'sleep'`           | When the camera end moving. |\r\n     *\r\n     * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means \"start\" and \"end\" cannot be detected.\r\n     * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).\r\n     *\r\n     * e.g.\r\n     * ```\r\n     * cameraControl.addEventListener( 'controlstart', myCallbackFunction );\r\n     * ```\r\n     * @param type event name\r\n     * @param listener handler function\r\n     * @category Methods\r\n     */\r\n    addEventListener(type, listener) {\r\n        super.addEventListener(type, listener);\r\n    }\r\n    /**\r\n     * Removes the specified event listener\r\n     * e.g.\r\n     * ```\r\n     * cameraControl.addEventListener( 'controlstart', myCallbackFunction );\r\n     * ```\r\n     * @param type event name\r\n     * @param listener handler function\r\n     * @category Methods\r\n     */\r\n    removeEventListener(type, listener) {\r\n        super.removeEventListener(type, listener);\r\n    }\r\n    /**\r\n     * Rotate azimuthal angle(horizontal) and polar angle(vertical).\r\n     * Every value is added to the current value.\r\n     * @param azimuthAngle Azimuth rotate angle. In radian.\r\n     * @param polarAngle Polar rotate angle. In radian.\r\n     * @param enableTransition Whether to move smoothly or immediately\r\n     * @category Methods\r\n     */\r\n    rotate(azimuthAngle, polarAngle, enableTransition = false) {\r\n        return this.rotateTo(this._sphericalEnd.theta + azimuthAngle, this._sphericalEnd.phi + polarAngle, enableTransition);\r\n    }\r\n    /**\r\n     * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.\r\n     *\r\n     * e.g.\r\n     * ```\r\n     * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );\r\n     * ```\r\n     * @param azimuthAngle Azimuth rotate angle. In radian.\r\n     * @param enableTransition Whether to move smoothly or immediately\r\n     * @category Methods\r\n     */\r\n    rotateAzimuthTo(azimuthAngle, enableTransition = false) {\r\n        return this.rotateTo(azimuthAngle, this._sphericalEnd.phi, enableTransition);\r\n    }\r\n    /**\r\n     * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.\r\n     *\r\n     * e.g.\r\n     * ```\r\n     * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );\r\n     * ```\r\n     * @param polarAngle Polar rotate angle. In radian.\r\n     * @param enableTransition Whether to move smoothly or immediately\r\n     * @category Methods\r\n     */\r\n    rotatePolarTo(polarAngle, enableTransition = false) {\r\n        return this.rotateTo(this._sphericalEnd.theta, polarAngle, enableTransition);\r\n    }\r\n    /**\r\n     * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.\r\n     * Camera view will rotate over the orbit pivot absolutely:\r\n     *\r\n     * azimuthAngle\r\n     * ```\r\n     *       0º\r\n     *         \\\r\n     * 90º -----+----- -90º\r\n     *           \\\r\n     *           180º\r\n     * ```\r\n     * | direction | angle                  |\r\n     * | --------- | ---------------------- |\r\n     * | front     | 0º                     |\r\n     * | left      | 90º (`Math.PI / 2`)    |\r\n     * | right     | -90º (`- Math.PI / 2`) |\r\n     * | back      | 180º (`Math.PI`)       |\r\n     *\r\n     * polarAngle\r\n     * ```\r\n     *     180º\r\n     *      |\r\n     *      90º\r\n     *      |\r\n     *      0º\r\n     * ```\r\n     * | direction            | angle                  |\r\n     * | -------------------- | ---------------------- |\r\n     * | top/sky              | 180º (`Math.PI`)       |\r\n     * | horizontal from view | 90º (`Math.PI / 2`)    |\r\n     * | bottom/floor         | 0º                     |\r\n     *\r\n     * @param azimuthAngle Azimuth rotate angle to. In radian.\r\n     * @param polarAngle Polar rotate angle to. In radian.\r\n     * @param enableTransition  Whether to move smoothly or immediately\r\n     * @category Methods\r\n     */\r\n    rotateTo(azimuthAngle, polarAngle, enableTransition = false) {\r\n        this._isUserControllingRotate = false;\r\n        const theta = clamp(azimuthAngle, this.minAzimuthAngle, this.maxAzimuthAngle);\r\n        const phi = clamp(polarAngle, this.minPolarAngle, this.maxPolarAngle);\r\n        this._sphericalEnd.theta = theta;\r\n        this._sphericalEnd.phi = phi;\r\n        this._sphericalEnd.makeSafe();\r\n        this._needsUpdate = true;\r\n        if (!enableTransition) {\r\n            this._spherical.theta = this._sphericalEnd.theta;\r\n            this._spherical.phi = this._sphericalEnd.phi;\r\n        }\r\n        const resolveImmediately = !enableTransition ||\r\n            approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) &&\r\n                approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);\r\n        return this._createOnRestPromise(resolveImmediately);\r\n    }\r\n    /**\r\n     * Dolly in/out camera position.\r\n     * @param distance Distance of dollyIn. Negative number for dollyOut.\r\n     * @param enableTransition Whether to move smoothly or immediately.\r\n     * @category Methods\r\n     */\r\n    dolly(distance, enableTransition = false) {\r\n        return this.dollyTo(this._sphericalEnd.radius - distance, enableTransition);\r\n    }\r\n    /**\r\n     * Dolly in/out camera position to given distance.\r\n     * @param distance Distance of dolly.\r\n     * @param enableTransition Whether to move smoothly or immediately.\r\n     * @category Methods\r\n     */\r\n    dollyTo(distance, enableTransition = false) {\r\n        this._isUserControllingDolly = false;\r\n        this._lastDollyDirection = DOLLY_DIRECTION.NONE;\r\n        this._changedDolly = 0;\r\n        return this._dollyToNoClamp(clamp(distance, this.minDistance, this.maxDistance), enableTransition);\r\n    }\r\n    _dollyToNoClamp(distance, enableTransition = false) {\r\n        const lastRadius = this._sphericalEnd.radius;\r\n        const hasCollider = this.colliderMeshes.length >= 1;\r\n        if (hasCollider) {\r\n            const maxDistanceByCollisionTest = this._collisionTest();\r\n            const isCollided = approxEquals(maxDistanceByCollisionTest, this._spherical.radius);\r\n            const isDollyIn = lastRadius > distance;\r\n            if (!isDollyIn && isCollided)\r\n                return Promise.resolve();\r\n            this._sphericalEnd.radius = Math.min(distance, maxDistanceByCollisionTest);\r\n        }\r\n        else {\r\n            this._sphericalEnd.radius = distance;\r\n        }\r\n        this._needsUpdate = true;\r\n        if (!enableTransition) {\r\n            this._spherical.radius = this._sphericalEnd.radius;\r\n        }\r\n        const resolveImmediately = !enableTransition || approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);\r\n        return this._createOnRestPromise(resolveImmediately);\r\n    }\r\n    /**\r\n     * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.\r\n     * Specify a negative value for dolly out.\r\n     * @param distance Distance of dolly.\r\n     * @param enableTransition Whether to move smoothly or immediately.\r\n     * @category Methods\r\n     */\r\n    dollyInFixed(distance, enableTransition = false) {\r\n        this._targetEnd.add(this._getCameraDirection(_cameraDirection).multiplyScalar(distance));\r\n        if (!enableTransition) {\r\n            this._target.copy(this._targetEnd);\r\n        }\r\n        const resolveImmediately = !enableTransition ||\r\n            approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) &&\r\n                approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) &&\r\n                approxEquals(this._target.z, this._targetEnd.z, this.restThreshold);\r\n        return this._createOnRestPromise(resolveImmediately);\r\n    }\r\n    /**\r\n     * Zoom in/out camera. The value is added to camera zoom.\r\n     * Limits set with `.minZoom` and `.maxZoom`\r\n     * @param zoomStep zoom scale\r\n     * @param enableTransition Whether to move smoothly or immediately\r\n     * @category Methods\r\n     */\r\n    zoom(zoomStep, enableTransition = false) {\r\n        return this.zoomTo(this._zoomEnd + zoomStep, enableTransition);\r\n    }\r\n    /**\r\n     * Zoom in/out camera to given scale. The value overwrites camera zoom.\r\n     * Limits set with .minZoom and .maxZoom\r\n     * @param zoom\r\n     * @param enableTransition\r\n     * @category Methods\r\n     */\r\n    zoomTo(zoom, enableTransition = false) {\r\n        this._isUserControllingZoom = false;\r\n        this._zoomEnd = clamp(zoom, this.minZoom, this.maxZoom);\r\n        this._needsUpdate = true;\r\n        if (!enableTransition) {\r\n            this._zoom = this._zoomEnd;\r\n        }\r\n        const resolveImmediately = !enableTransition || approxEquals(this._zoom, this._zoomEnd, this.restThreshold);\r\n        this._changedZoom = 0;\r\n        return this._createOnRestPromise(resolveImmediately);\r\n    }\r\n    /**\r\n     * @deprecated `pan()` has been renamed to `truck()`\r\n     * @category Methods\r\n     */\r\n    pan(x, y, enableTransition = false) {\r\n        console.warn('`pan` has been renamed to `truck`');\r\n        return this.truck(x, y, enableTransition);\r\n    }\r\n    /**\r\n     * Truck and pedestal camera using current azimuthal angle\r\n     * @param x Horizontal translate amount\r\n     * @param y Vertical translate amount\r\n     * @param enableTransition Whether to move smoothly or immediately\r\n     * @category Methods\r\n     */\r\n    truck(x, y, enableTransition = false) {\r\n        this._camera.updateMatrix();\r\n        _xColumn.setFromMatrixColumn(this._camera.matrix, 0);\r\n        _yColumn.setFromMatrixColumn(this._camera.matrix, 1);\r\n        _xColumn.multiplyScalar(x);\r\n        _yColumn.multiplyScalar(-y);\r\n        const offset = _v3A.copy(_xColumn).add(_yColumn);\r\n        const to = _v3B.copy(this._targetEnd).add(offset);\r\n        return this.moveTo(to.x, to.y, to.z, enableTransition);\r\n    }\r\n    /**\r\n     * Move forward / backward.\r\n     * @param distance Amount to move forward / backward. Negative value to move backward\r\n     * @param enableTransition Whether to move smoothly or immediately\r\n     * @category Methods\r\n     */\r\n    forward(distance, enableTransition = false) {\r\n        _v3A.setFromMatrixColumn(this._camera.matrix, 0);\r\n        _v3A.crossVectors(this._camera.up, _v3A);\r\n        _v3A.multiplyScalar(distance);\r\n        const to = _v3B.copy(this._targetEnd).add(_v3A);\r\n        return this.moveTo(to.x, to.y, to.z, enableTransition);\r\n    }\r\n    /**\r\n     * Move up / down.\r\n     * @param height Amount to move up / down. Negative value to move down\r\n     * @param enableTransition Whether to move smoothly or immediately\r\n     * @category Methods\r\n     */\r\n    elevate(height, enableTransition = false) {\r\n        _v3A.copy(this._camera.up).multiplyScalar(height);\r\n        return this.moveTo(this._targetEnd.x + _v3A.x, this._targetEnd.y + _v3A.y, this._targetEnd.z + _v3A.z, enableTransition);\r\n    }\r\n    /**\r\n     * Move target position to given point.\r\n     * @param x x coord to move center position\r\n     * @param y y coord to move center position\r\n     * @param z z coord to move center position\r\n     * @param enableTransition Whether to move smoothly or immediately\r\n     * @category Methods\r\n     */\r\n    moveTo(x, y, z, enableTransition = false) {\r\n        this._isUserControllingTruck = false;\r\n        const offset = _v3A.set(x, y, z).sub(this._targetEnd);\r\n        this._encloseToBoundary(this._targetEnd, offset, this.boundaryFriction);\r\n        this._needsUpdate = true;\r\n        if (!enableTransition) {\r\n            this._target.copy(this._targetEnd);\r\n        }\r\n        const resolveImmediately = !enableTransition ||\r\n            approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) &&\r\n                approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) &&\r\n                approxEquals(this._target.z, this._targetEnd.z, this.restThreshold);\r\n        return this._createOnRestPromise(resolveImmediately);\r\n    }\r\n    /**\r\n     * Look in the given point direction.\r\n     * @param x point x.\r\n     * @param y point y.\r\n     * @param z point z.\r\n     * @param enableTransition Whether to move smoothly or immediately.\r\n     * @returns Transition end promise\r\n     * @category Methods\r\n     */\r\n    lookInDirectionOf(x, y, z, enableTransition = false) {\r\n        const point = _v3A.set(x, y, z);\r\n        const direction = point.sub(this._targetEnd).normalize();\r\n        const position = direction.multiplyScalar(-this._sphericalEnd.radius);\r\n        return this.setPosition(position.x, position.y, position.z, enableTransition);\r\n    }\r\n    /**\r\n     * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.\r\n     * set `cover: true` to fill enter screen.\r\n     * e.g.\r\n     * ```\r\n     * cameraControls.fitToBox( myMesh );\r\n     * ```\r\n     * @param box3OrObject Axis aligned bounding box to fit the view.\r\n     * @param enableTransition Whether to move smoothly or immediately.\r\n     * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }\r\n     * @returns Transition end promise\r\n     * @category Methods\r\n     */\r\n    fitToBox(box3OrObject, enableTransition, { cover = false, paddingLeft = 0, paddingRight = 0, paddingBottom = 0, paddingTop = 0 } = {}) {\r\n        const promises = [];\r\n        const aabb = box3OrObject.isBox3\r\n            ? _box3A.copy(box3OrObject)\r\n            : _box3A.setFromObject(box3OrObject);\r\n        if (aabb.isEmpty()) {\r\n            console.warn('camera-controls: fitTo() cannot be used with an empty box. Aborting');\r\n            Promise.resolve();\r\n        }\r\n        // round to closest axis ( forward | backward | right | left | top | bottom )\r\n        const theta = roundToStep(this._sphericalEnd.theta, PI_HALF);\r\n        const phi = roundToStep(this._sphericalEnd.phi, PI_HALF);\r\n        promises.push(this.rotateTo(theta, phi, enableTransition));\r\n        const normal = _v3A.setFromSpherical(this._sphericalEnd).normalize();\r\n        const rotation = _quaternionA.setFromUnitVectors(normal, _AXIS_Z);\r\n        const viewFromPolar = approxEquals(Math.abs(normal.y), 1);\r\n        if (viewFromPolar) {\r\n            rotation.multiply(_quaternionB.setFromAxisAngle(_AXIS_Y, theta));\r\n        }\r\n        rotation.multiply(this._yAxisUpSpaceInverse);\r\n        // make oriented bounding box\r\n        const bb = _box3B.makeEmpty();\r\n        // left bottom back corner\r\n        _v3B.copy(aabb.min).applyQuaternion(rotation);\r\n        bb.expandByPoint(_v3B);\r\n        // right bottom back corner\r\n        _v3B.copy(aabb.min).setX(aabb.max.x).applyQuaternion(rotation);\r\n        bb.expandByPoint(_v3B);\r\n        // left top back corner\r\n        _v3B.copy(aabb.min).setY(aabb.max.y).applyQuaternion(rotation);\r\n        bb.expandByPoint(_v3B);\r\n        // right top back corner\r\n        _v3B.copy(aabb.max).setZ(aabb.min.z).applyQuaternion(rotation);\r\n        bb.expandByPoint(_v3B);\r\n        // left bottom front corner\r\n        _v3B.copy(aabb.min).setZ(aabb.max.z).applyQuaternion(rotation);\r\n        bb.expandByPoint(_v3B);\r\n        // right bottom front corner\r\n        _v3B.copy(aabb.max).setY(aabb.min.y).applyQuaternion(rotation);\r\n        bb.expandByPoint(_v3B);\r\n        // left top front corner\r\n        _v3B.copy(aabb.max).setX(aabb.min.x).applyQuaternion(rotation);\r\n        bb.expandByPoint(_v3B);\r\n        // right top front corner\r\n        _v3B.copy(aabb.max).applyQuaternion(rotation);\r\n        bb.expandByPoint(_v3B);\r\n        // add padding\r\n        bb.min.x -= paddingLeft;\r\n        bb.min.y -= paddingBottom;\r\n        bb.max.x += paddingRight;\r\n        bb.max.y += paddingTop;\r\n        rotation.setFromUnitVectors(_AXIS_Z, normal);\r\n        if (viewFromPolar) {\r\n            rotation.premultiply(_quaternionB.invert());\r\n        }\r\n        rotation.premultiply(this._yAxisUpSpace);\r\n        const bbSize = bb.getSize(_v3A);\r\n        const center = bb.getCenter(_v3B).applyQuaternion(rotation);\r\n        if (isPerspectiveCamera(this._camera)) {\r\n            const distance = this.getDistanceToFitBox(bbSize.x, bbSize.y, bbSize.z, cover);\r\n            promises.push(this.moveTo(center.x, center.y, center.z, enableTransition));\r\n            promises.push(this.dollyTo(distance, enableTransition));\r\n            promises.push(this.setFocalOffset(0, 0, 0, enableTransition));\r\n        }\r\n        else if (isOrthographicCamera(this._camera)) {\r\n            const camera = this._camera;\r\n            const width = camera.right - camera.left;\r\n            const height = camera.top - camera.bottom;\r\n            const zoom = cover ? Math.max(width / bbSize.x, height / bbSize.y) : Math.min(width / bbSize.x, height / bbSize.y);\r\n            promises.push(this.moveTo(center.x, center.y, center.z, enableTransition));\r\n            promises.push(this.zoomTo(zoom, enableTransition));\r\n            promises.push(this.setFocalOffset(0, 0, 0, enableTransition));\r\n        }\r\n        return Promise.all(promises);\r\n    }\r\n    /**\r\n     * Fit the viewport to the sphere or the bounding sphere of the object.\r\n     * @param sphereOrMesh\r\n     * @param enableTransition\r\n     * @category Methods\r\n     */\r\n    fitToSphere(sphereOrMesh, enableTransition) {\r\n        const promises = [];\r\n        const isSphere = sphereOrMesh instanceof THREE.Sphere;\r\n        const boundingSphere = isSphere ?\r\n            _sphere.copy(sphereOrMesh) :\r\n            CameraControls.createBoundingSphere(sphereOrMesh, _sphere);\r\n        promises.push(this.moveTo(boundingSphere.center.x, boundingSphere.center.y, boundingSphere.center.z, enableTransition));\r\n        if (isPerspectiveCamera(this._camera)) {\r\n            const distanceToFit = this.getDistanceToFitSphere(boundingSphere.radius);\r\n            promises.push(this.dollyTo(distanceToFit, enableTransition));\r\n        }\r\n        else if (isOrthographicCamera(this._camera)) {\r\n            const width = this._camera.right - this._camera.left;\r\n            const height = this._camera.top - this._camera.bottom;\r\n            const diameter = 2 * boundingSphere.radius;\r\n            const zoom = Math.min(width / diameter, height / diameter);\r\n            promises.push(this.zoomTo(zoom, enableTransition));\r\n        }\r\n        promises.push(this.setFocalOffset(0, 0, 0, enableTransition));\r\n        return Promise.all(promises);\r\n    }\r\n    /**\r\n     * Look at the `target` from the `position`.\r\n     * @param positionX\r\n     * @param positionY\r\n     * @param positionZ\r\n     * @param targetX\r\n     * @param targetY\r\n     * @param targetZ\r\n     * @param enableTransition\r\n     * @category Methods\r\n     */\r\n    setLookAt(positionX, positionY, positionZ, targetX, targetY, targetZ, enableTransition = false) {\r\n        this._isUserControllingRotate = false;\r\n        this._isUserControllingDolly = false;\r\n        this._isUserControllingTruck = false;\r\n        this._lastDollyDirection = DOLLY_DIRECTION.NONE;\r\n        this._changedDolly = 0;\r\n        const target = _v3B.set(targetX, targetY, targetZ);\r\n        const position = _v3A.set(positionX, positionY, positionZ);\r\n        this._targetEnd.copy(target);\r\n        this._sphericalEnd.setFromVector3(position.sub(target).applyQuaternion(this._yAxisUpSpace));\r\n        this.normalizeRotations();\r\n        this._needsUpdate = true;\r\n        if (!enableTransition) {\r\n            this._target.copy(this._targetEnd);\r\n            this._spherical.copy(this._sphericalEnd);\r\n        }\r\n        const resolveImmediately = !enableTransition ||\r\n            approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) &&\r\n                approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) &&\r\n                approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) &&\r\n                approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) &&\r\n                approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) &&\r\n                approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);\r\n        return this._createOnRestPromise(resolveImmediately);\r\n    }\r\n    /**\r\n     * Similar to setLookAt, but it interpolates between two states.\r\n     * @param positionAX\r\n     * @param positionAY\r\n     * @param positionAZ\r\n     * @param targetAX\r\n     * @param targetAY\r\n     * @param targetAZ\r\n     * @param positionBX\r\n     * @param positionBY\r\n     * @param positionBZ\r\n     * @param targetBX\r\n     * @param targetBY\r\n     * @param targetBZ\r\n     * @param t\r\n     * @param enableTransition\r\n     * @category Methods\r\n     */\r\n    lerpLookAt(positionAX, positionAY, positionAZ, targetAX, targetAY, targetAZ, positionBX, positionBY, positionBZ, targetBX, targetBY, targetBZ, t, enableTransition = false) {\r\n        this._isUserControllingRotate = false;\r\n        this._isUserControllingDolly = false;\r\n        this._isUserControllingTruck = false;\r\n        this._lastDollyDirection = DOLLY_DIRECTION.NONE;\r\n        this._changedDolly = 0;\r\n        const targetA = _v3A.set(targetAX, targetAY, targetAZ);\r\n        const positionA = _v3B.set(positionAX, positionAY, positionAZ);\r\n        _sphericalA.setFromVector3(positionA.sub(targetA).applyQuaternion(this._yAxisUpSpace));\r\n        const targetB = _v3C.set(targetBX, targetBY, targetBZ);\r\n        const positionB = _v3B.set(positionBX, positionBY, positionBZ);\r\n        _sphericalB.setFromVector3(positionB.sub(targetB).applyQuaternion(this._yAxisUpSpace));\r\n        this._targetEnd.copy(targetA.lerp(targetB, t)); // tricky\r\n        const deltaTheta = _sphericalB.theta - _sphericalA.theta;\r\n        const deltaPhi = _sphericalB.phi - _sphericalA.phi;\r\n        const deltaRadius = _sphericalB.radius - _sphericalA.radius;\r\n        this._sphericalEnd.set(_sphericalA.radius + deltaRadius * t, _sphericalA.phi + deltaPhi * t, _sphericalA.theta + deltaTheta * t);\r\n        this.normalizeRotations();\r\n        this._needsUpdate = true;\r\n        if (!enableTransition) {\r\n            this._target.copy(this._targetEnd);\r\n            this._spherical.copy(this._sphericalEnd);\r\n        }\r\n        const resolveImmediately = !enableTransition ||\r\n            approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) &&\r\n                approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) &&\r\n                approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) &&\r\n                approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) &&\r\n                approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) &&\r\n                approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);\r\n        return this._createOnRestPromise(resolveImmediately);\r\n    }\r\n    /**\r\n     * Set angle and distance by given position.\r\n     * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target\r\n     * @param positionX\r\n     * @param positionY\r\n     * @param positionZ\r\n     * @param enableTransition\r\n     * @category Methods\r\n     */\r\n    setPosition(positionX, positionY, positionZ, enableTransition = false) {\r\n        return this.setLookAt(positionX, positionY, positionZ, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, enableTransition);\r\n    }\r\n    /**\r\n     * Set the target position where gaze at.\r\n     * An alias of `setLookAt()`, without position change. Thus keep the same position.\r\n     * @param targetX\r\n     * @param targetY\r\n     * @param targetZ\r\n     * @param enableTransition\r\n     * @category Methods\r\n     */\r\n    setTarget(targetX, targetY, targetZ, enableTransition = false) {\r\n        const pos = this.getPosition(_v3A);\r\n        const promise = this.setLookAt(pos.x, pos.y, pos.z, targetX, targetY, targetZ, enableTransition);\r\n        // see https://github.com/yomotsu/camera-controls/issues/335\r\n        this._sphericalEnd.phi = clamp(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle);\r\n        return promise;\r\n    }\r\n    /**\r\n     * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.\r\n     * @param x\r\n     * @param y\r\n     * @param z\r\n     * @param enableTransition\r\n     * @category Methods\r\n     */\r\n    setFocalOffset(x, y, z, enableTransition = false) {\r\n        this._isUserControllingOffset = false;\r\n        this._focalOffsetEnd.set(x, y, z);\r\n        this._needsUpdate = true;\r\n        if (!enableTransition)\r\n            this._focalOffset.copy(this._focalOffsetEnd);\r\n        const resolveImmediately = !enableTransition ||\r\n            approxEquals(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) &&\r\n                approxEquals(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) &&\r\n                approxEquals(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);\r\n        return this._createOnRestPromise(resolveImmediately);\r\n    }\r\n    /**\r\n     * Set orbit point without moving the camera.\r\n     * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.\r\n     * @param targetX\r\n     * @param targetY\r\n     * @param targetZ\r\n     * @category Methods\r\n     */\r\n    setOrbitPoint(targetX, targetY, targetZ) {\r\n        this._camera.updateMatrixWorld();\r\n        _xColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 0);\r\n        _yColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 1);\r\n        _zColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);\r\n        const position = _v3A.set(targetX, targetY, targetZ);\r\n        const distance = position.distanceTo(this._camera.position);\r\n        const cameraToPoint = position.sub(this._camera.position);\r\n        _xColumn.multiplyScalar(cameraToPoint.x);\r\n        _yColumn.multiplyScalar(cameraToPoint.y);\r\n        _zColumn.multiplyScalar(cameraToPoint.z);\r\n        _v3A.copy(_xColumn).add(_yColumn).add(_zColumn);\r\n        _v3A.z = _v3A.z + distance;\r\n        this.dollyTo(distance, false);\r\n        this.setFocalOffset(-_v3A.x, _v3A.y, -_v3A.z, false);\r\n        this.moveTo(targetX, targetY, targetZ, false);\r\n    }\r\n    /**\r\n     * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3\r\n     * @param box3\r\n     * @category Methods\r\n     */\r\n    setBoundary(box3) {\r\n        if (!box3) {\r\n            this._boundary.min.set(-Infinity, -Infinity, -Infinity);\r\n            this._boundary.max.set(Infinity, Infinity, Infinity);\r\n            this._needsUpdate = true;\r\n            return;\r\n        }\r\n        this._boundary.copy(box3);\r\n        this._boundary.clampPoint(this._targetEnd, this._targetEnd);\r\n        this._needsUpdate = true;\r\n    }\r\n    /**\r\n     * Set (or unset) the current viewport.\r\n     * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.\r\n     * @param viewportOrX\r\n     * @param y\r\n     * @param width\r\n     * @param height\r\n     * @category Methods\r\n     */\r\n    setViewport(viewportOrX, y, width, height) {\r\n        if (viewportOrX === null) { // null\r\n            this._viewport = null;\r\n            return;\r\n        }\r\n        this._viewport = this._viewport || new THREE.Vector4();\r\n        if (typeof viewportOrX === 'number') { // number\r\n            this._viewport.set(viewportOrX, y, width, height);\r\n        }\r\n        else { // Vector4\r\n            this._viewport.copy(viewportOrX);\r\n        }\r\n    }\r\n    /**\r\n     * Calculate the distance to fit the box.\r\n     * @param width box width\r\n     * @param height box height\r\n     * @param depth box depth\r\n     * @returns distance\r\n     * @category Methods\r\n     */\r\n    getDistanceToFitBox(width, height, depth, cover = false) {\r\n        if (notSupportedInOrthographicCamera(this._camera, 'getDistanceToFitBox'))\r\n            return this._spherical.radius;\r\n        const boundingRectAspect = width / height;\r\n        const fov = this._camera.getEffectiveFOV() * DEG2RAD;\r\n        const aspect = this._camera.aspect;\r\n        const heightToFit = (cover ? boundingRectAspect > aspect : boundingRectAspect < aspect) ? height : width / aspect;\r\n        return heightToFit * 0.5 / Math.tan(fov * 0.5) + depth * 0.5;\r\n    }\r\n    /**\r\n     * Calculate the distance to fit the sphere.\r\n     * @param radius sphere radius\r\n     * @returns distance\r\n     * @category Methods\r\n     */\r\n    getDistanceToFitSphere(radius) {\r\n        if (notSupportedInOrthographicCamera(this._camera, 'getDistanceToFitSphere'))\r\n            return this._spherical.radius;\r\n        // https://stackoverflow.com/a/44849975\r\n        const vFOV = this._camera.getEffectiveFOV() * DEG2RAD;\r\n        const hFOV = Math.atan(Math.tan(vFOV * 0.5) * this._camera.aspect) * 2;\r\n        const fov = 1 < this._camera.aspect ? vFOV : hFOV;\r\n        return radius / (Math.sin(fov * 0.5));\r\n    }\r\n    /**\r\n     * Returns the orbit center position, where the camera looking at.\r\n     * @param out The receiving Vector3 instance to copy the result\r\n     * @param receiveEndValue Whether receive the transition end coords or current. default is `true`\r\n     * @category Methods\r\n     */\r\n    getTarget(out, receiveEndValue = true) {\r\n        const _out = !!out && out.isVector3 ? out : new THREE.Vector3();\r\n        return _out.copy(receiveEndValue ? this._targetEnd : this._target);\r\n    }\r\n    /**\r\n     * Returns the camera position.\r\n     * @param out The receiving Vector3 instance to copy the result\r\n     * @param receiveEndValue Whether receive the transition end coords or current. default is `true`\r\n     * @category Methods\r\n     */\r\n    getPosition(out, receiveEndValue = true) {\r\n        const _out = !!out && out.isVector3 ? out : new THREE.Vector3();\r\n        return _out.setFromSpherical(receiveEndValue ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(receiveEndValue ? this._targetEnd : this._target);\r\n    }\r\n    /**\r\n     * Returns the spherical coordinates of the orbit.\r\n     * @param out The receiving Spherical instance to copy the result\r\n     * @param receiveEndValue Whether receive the transition end coords or current. default is `true`\r\n     * @category Methods\r\n     */\r\n    getSpherical(out, receiveEndValue = true) {\r\n        const _out = !!out && out instanceof THREE.Spherical ? out : new THREE.Spherical();\r\n        return _out.copy(receiveEndValue ? this._sphericalEnd : this._spherical);\r\n    }\r\n    /**\r\n     * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.\r\n     * @param out The receiving Vector3 instance to copy the result\r\n     * @param receiveEndValue Whether receive the transition end coords or current. default is `true`\r\n     * @category Methods\r\n     */\r\n    getFocalOffset(out, receiveEndValue = true) {\r\n        const _out = !!out && out.isVector3 ? out : new THREE.Vector3();\r\n        return _out.copy(receiveEndValue ? this._focalOffsetEnd : this._focalOffset);\r\n    }\r\n    /**\r\n     * Normalize camera azimuth angle rotation between 0 and 360 degrees.\r\n     * @category Methods\r\n     */\r\n    normalizeRotations() {\r\n        this._sphericalEnd.theta = this._sphericalEnd.theta % PI_2;\r\n        if (this._sphericalEnd.theta < 0)\r\n            this._sphericalEnd.theta += PI_2;\r\n        this._spherical.theta += PI_2 * Math.round((this._sphericalEnd.theta - this._spherical.theta) / PI_2);\r\n    }\r\n    /**\r\n     * Reset all rotation and position to defaults.\r\n     * @param enableTransition\r\n     * @category Methods\r\n     */\r\n    reset(enableTransition = false) {\r\n        if (!approxEquals(this._camera.up.x, this._cameraUp0.x) ||\r\n            !approxEquals(this._camera.up.y, this._cameraUp0.y) ||\r\n            !approxEquals(this._camera.up.z, this._cameraUp0.z)) {\r\n            this._camera.up.copy(this._cameraUp0);\r\n            const position = this.getPosition(_v3A);\r\n            this.updateCameraUp();\r\n            this.setPosition(position.x, position.y, position.z);\r\n        }\r\n        const promises = [\r\n            this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, enableTransition),\r\n            this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, enableTransition),\r\n            this.zoomTo(this._zoom0, enableTransition),\r\n        ];\r\n        return Promise.all(promises);\r\n    }\r\n    /**\r\n     * Set current camera position as the default position.\r\n     * @category Methods\r\n     */\r\n    saveState() {\r\n        this._cameraUp0.copy(this._camera.up);\r\n        this.getTarget(this._target0);\r\n        this.getPosition(this._position0);\r\n        this._zoom0 = this._zoom;\r\n        this._focalOffset0.copy(this._focalOffset);\r\n    }\r\n    /**\r\n     * Sync camera-up direction.\r\n     * When camera-up vector is changed, `.updateCameraUp()` must be called.\r\n     * @category Methods\r\n     */\r\n    updateCameraUp() {\r\n        this._yAxisUpSpace.setFromUnitVectors(this._camera.up, _AXIS_Y);\r\n        this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();\r\n    }\r\n    /**\r\n     * Apply current camera-up direction to the camera.\r\n     * The orbit system will be re-initialized with the current position.\r\n     * @category Methods\r\n     */\r\n    applyCameraUp() {\r\n        const cameraDirection = _v3A.subVectors(this._target, this._camera.position).normalize();\r\n        // So first find the vector off to the side, orthogonal to both this.object.up and\r\n        // the \"view\" vector.\r\n        const side = _v3B.crossVectors(cameraDirection, this._camera.up);\r\n        // Then find the vector orthogonal to both this \"side\" vector and the \"view\" vector.\r\n        // This vector will be the new \"up\" vector.\r\n        this._camera.up.crossVectors(side, cameraDirection).normalize();\r\n        this._camera.updateMatrixWorld();\r\n        const position = this.getPosition(_v3A);\r\n        this.updateCameraUp();\r\n        this.setPosition(position.x, position.y, position.z);\r\n    }\r\n    /**\r\n     * Update camera position and directions.\r\n     * This should be called in your tick loop every time, and returns true if re-rendering is needed.\r\n     * @param delta\r\n     * @returns updated\r\n     * @category Methods\r\n     */\r\n    update(delta) {\r\n        const deltaTheta = this._sphericalEnd.theta - this._spherical.theta;\r\n        const deltaPhi = this._sphericalEnd.phi - this._spherical.phi;\r\n        const deltaRadius = this._sphericalEnd.radius - this._spherical.radius;\r\n        const deltaTarget = _deltaTarget.subVectors(this._targetEnd, this._target);\r\n        const deltaOffset = _deltaOffset.subVectors(this._focalOffsetEnd, this._focalOffset);\r\n        const deltaZoom = this._zoomEnd - this._zoom;\r\n        // update theta\r\n        if (approxZero(deltaTheta)) {\r\n            this._thetaVelocity.value = 0;\r\n            this._spherical.theta = this._sphericalEnd.theta;\r\n        }\r\n        else {\r\n            const smoothTime = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;\r\n            this._spherical.theta = smoothDamp(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, smoothTime, Infinity, delta);\r\n            this._needsUpdate = true;\r\n        }\r\n        // update phi\r\n        if (approxZero(deltaPhi)) {\r\n            this._phiVelocity.value = 0;\r\n            this._spherical.phi = this._sphericalEnd.phi;\r\n        }\r\n        else {\r\n            const smoothTime = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;\r\n            this._spherical.phi = smoothDamp(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, smoothTime, Infinity, delta);\r\n            this._needsUpdate = true;\r\n        }\r\n        // update distance\r\n        if (approxZero(deltaRadius)) {\r\n            this._radiusVelocity.value = 0;\r\n            this._spherical.radius = this._sphericalEnd.radius;\r\n        }\r\n        else {\r\n            const smoothTime = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;\r\n            this._spherical.radius = smoothDamp(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, smoothTime, this.maxSpeed, delta);\r\n            this._needsUpdate = true;\r\n        }\r\n        // update target position\r\n        if (approxZero(deltaTarget.x) && approxZero(deltaTarget.y) && approxZero(deltaTarget.z)) {\r\n            this._targetVelocity.set(0, 0, 0);\r\n            this._target.copy(this._targetEnd);\r\n        }\r\n        else {\r\n            const smoothTime = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;\r\n            smoothDampVec3(this._target, this._targetEnd, this._targetVelocity, smoothTime, this.maxSpeed, delta, this._target);\r\n            this._needsUpdate = true;\r\n        }\r\n        // update focalOffset\r\n        if (approxZero(deltaOffset.x) && approxZero(deltaOffset.y) && approxZero(deltaOffset.z)) {\r\n            this._focalOffsetVelocity.set(0, 0, 0);\r\n            this._focalOffset.copy(this._focalOffsetEnd);\r\n        }\r\n        else {\r\n            const smoothTime = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;\r\n            smoothDampVec3(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, smoothTime, this.maxSpeed, delta, this._focalOffset);\r\n            this._needsUpdate = true;\r\n        }\r\n        // update zoom\r\n        if (approxZero(deltaZoom)) {\r\n            this._zoomVelocity.value = 0;\r\n            this._zoom = this._zoomEnd;\r\n        }\r\n        else {\r\n            const smoothTime = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;\r\n            this._zoom = smoothDamp(this._zoom, this._zoomEnd, this._zoomVelocity, smoothTime, Infinity, delta);\r\n        }\r\n        if (this.dollyToCursor) {\r\n            if (isPerspectiveCamera(this._camera) && this._changedDolly !== 0) {\r\n                const dollyControlAmount = this._spherical.radius - this._lastDistance;\r\n                const camera = this._camera;\r\n                const cameraDirection = this._getCameraDirection(_cameraDirection);\r\n                const planeX = _v3A.copy(cameraDirection).cross(camera.up).normalize();\r\n                if (planeX.lengthSq() === 0)\r\n                    planeX.x = 1.0;\r\n                const planeY = _v3B.crossVectors(planeX, cameraDirection);\r\n                const worldToScreen = this._sphericalEnd.radius * Math.tan(camera.getEffectiveFOV() * DEG2RAD * 0.5);\r\n                const prevRadius = this._sphericalEnd.radius - dollyControlAmount;\r\n                const lerpRatio = (prevRadius - this._sphericalEnd.radius) / this._sphericalEnd.radius;\r\n                const cursor = _v3C.copy(this._targetEnd)\r\n                    .add(planeX.multiplyScalar(this._dollyControlCoord.x * worldToScreen * camera.aspect))\r\n                    .add(planeY.multiplyScalar(this._dollyControlCoord.y * worldToScreen));\r\n                const newTargetEnd = _v3A.copy(this._targetEnd).lerp(cursor, lerpRatio);\r\n                const isMin = this._lastDollyDirection === DOLLY_DIRECTION.IN && this._spherical.radius <= this.minDistance;\r\n                const isMax = this._lastDollyDirection === DOLLY_DIRECTION.OUT && this.maxDistance <= this._spherical.radius;\r\n                if (this.infinityDolly && (isMin || isMax)) {\r\n                    this._sphericalEnd.radius -= dollyControlAmount;\r\n                    this._spherical.radius -= dollyControlAmount;\r\n                    const dollyAmount = _v3B.copy(cameraDirection).multiplyScalar(-dollyControlAmount);\r\n                    newTargetEnd.add(dollyAmount);\r\n                }\r\n                // target position may be moved beyond boundary.\r\n                this._boundary.clampPoint(newTargetEnd, newTargetEnd);\r\n                const targetEndDiff = _v3B.subVectors(newTargetEnd, this._targetEnd);\r\n                this._targetEnd.copy(newTargetEnd);\r\n                this._target.add(targetEndDiff);\r\n                this._changedDolly -= dollyControlAmount;\r\n                if (approxZero(this._changedDolly))\r\n                    this._changedDolly = 0;\r\n            }\r\n            else if (isOrthographicCamera(this._camera) && this._changedZoom !== 0) {\r\n                const dollyControlAmount = this._zoom - this._lastZoom;\r\n                const camera = this._camera;\r\n                const worldCursorPosition = _v3A.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);\r\n                const quaternion = _v3B.set(0, 0, -1).applyQuaternion(camera.quaternion);\r\n                const cursor = _v3C.copy(worldCursorPosition).add(quaternion.multiplyScalar(-worldCursorPosition.dot(camera.up)));\r\n                const prevZoom = this._zoom - dollyControlAmount;\r\n                const lerpRatio = -(prevZoom - this._zoom) / this._zoom;\r\n                // find the \"distance\" (aka plane constant in three.js) of Plane\r\n                // from a given position (this._targetEnd) and normal vector (cameraDirection)\r\n                // https://www.maplesoft.com/support/help/maple/view.aspx?path=MathApps%2FEquationOfAPlaneNormal#bkmrk0\r\n                const cameraDirection = this._getCameraDirection(_cameraDirection);\r\n                const prevPlaneConstant = this._targetEnd.dot(cameraDirection);\r\n                const newTargetEnd = _v3A.copy(this._targetEnd).lerp(cursor, lerpRatio);\r\n                const newPlaneConstant = newTargetEnd.dot(cameraDirection);\r\n                // Pull back the camera depth that has moved, to be the camera stationary as zoom\r\n                const pullBack = cameraDirection.multiplyScalar(newPlaneConstant - prevPlaneConstant);\r\n                newTargetEnd.sub(pullBack);\r\n                // target position may be moved beyond boundary.\r\n                this._boundary.clampPoint(newTargetEnd, newTargetEnd);\r\n                const targetEndDiff = _v3B.subVectors(newTargetEnd, this._targetEnd);\r\n                this._targetEnd.copy(newTargetEnd);\r\n                this._target.add(targetEndDiff);\r\n                // this._target.copy( this._targetEnd );\r\n                this._changedZoom -= dollyControlAmount;\r\n                if (approxZero(this._changedZoom))\r\n                    this._changedZoom = 0;\r\n            }\r\n        }\r\n        if (this._camera.zoom !== this._zoom) {\r\n            this._camera.zoom = this._zoom;\r\n            this._camera.updateProjectionMatrix();\r\n            this._updateNearPlaneCorners();\r\n            this._needsUpdate = true;\r\n        }\r\n        this._dragNeedsUpdate = true;\r\n        // collision detection\r\n        const maxDistance = this._collisionTest();\r\n        this._spherical.radius = Math.min(this._spherical.radius, maxDistance);\r\n        // decompose spherical to the camera position\r\n        this._spherical.makeSafe();\r\n        this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target);\r\n        this._camera.lookAt(this._target);\r\n        // set offset after the orbit movement\r\n        const affectOffset = !approxZero(this._focalOffset.x) ||\r\n            !approxZero(this._focalOffset.y) ||\r\n            !approxZero(this._focalOffset.z);\r\n        if (affectOffset) {\r\n            this._camera.updateMatrixWorld();\r\n            _xColumn.setFromMatrixColumn(this._camera.matrix, 0);\r\n            _yColumn.setFromMatrixColumn(this._camera.matrix, 1);\r\n            _zColumn.setFromMatrixColumn(this._camera.matrix, 2);\r\n            _xColumn.multiplyScalar(this._focalOffset.x);\r\n            _yColumn.multiplyScalar(-this._focalOffset.y);\r\n            _zColumn.multiplyScalar(this._focalOffset.z); // notice: z-offset will not affect in Orthographic.\r\n            _v3A.copy(_xColumn).add(_yColumn).add(_zColumn);\r\n            this._camera.position.add(_v3A);\r\n        }\r\n        if (this._boundaryEnclosesCamera) {\r\n            this._encloseToBoundary(this._camera.position.copy(this._target), _v3A.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1.0);\r\n        }\r\n        const updated = this._needsUpdate;\r\n        if (updated && !this._updatedLastTime) {\r\n            this._hasRested = false;\r\n            this.dispatchEvent({ type: 'wake' });\r\n            this.dispatchEvent({ type: 'update' });\r\n        }\r\n        else if (updated) {\r\n            this.dispatchEvent({ type: 'update' });\r\n            if (approxZero(deltaTheta, this.restThreshold) &&\r\n                approxZero(deltaPhi, this.restThreshold) &&\r\n                approxZero(deltaRadius, this.restThreshold) &&\r\n                approxZero(deltaTarget.x, this.restThreshold) &&\r\n                approxZero(deltaTarget.y, this.restThreshold) &&\r\n                approxZero(deltaTarget.z, this.restThreshold) &&\r\n                approxZero(deltaOffset.x, this.restThreshold) &&\r\n                approxZero(deltaOffset.y, this.restThreshold) &&\r\n                approxZero(deltaOffset.z, this.restThreshold) &&\r\n                approxZero(deltaZoom, this.restThreshold) &&\r\n                !this._hasRested) {\r\n                this._hasRested = true;\r\n                this.dispatchEvent({ type: 'rest' });\r\n            }\r\n        }\r\n        else if (!updated && this._updatedLastTime) {\r\n            this.dispatchEvent({ type: 'sleep' });\r\n        }\r\n        this._lastDistance = this._spherical.radius;\r\n        this._lastZoom = this._zoom;\r\n        this._updatedLastTime = updated;\r\n        this._needsUpdate = false;\r\n        return updated;\r\n    }\r\n    /**\r\n     * Get all state in JSON string\r\n     * @category Methods\r\n     */\r\n    toJSON() {\r\n        return JSON.stringify({\r\n            enabled: this._enabled,\r\n            minDistance: this.minDistance,\r\n            maxDistance: infinityToMaxNumber(this.maxDistance),\r\n            minZoom: this.minZoom,\r\n            maxZoom: infinityToMaxNumber(this.maxZoom),\r\n            minPolarAngle: this.minPolarAngle,\r\n            maxPolarAngle: infinityToMaxNumber(this.maxPolarAngle),\r\n            minAzimuthAngle: infinityToMaxNumber(this.minAzimuthAngle),\r\n            maxAzimuthAngle: infinityToMaxNumber(this.maxAzimuthAngle),\r\n            smoothTime: this.smoothTime,\r\n            draggingSmoothTime: this.draggingSmoothTime,\r\n            dollySpeed: this.dollySpeed,\r\n            truckSpeed: this.truckSpeed,\r\n            dollyToCursor: this.dollyToCursor,\r\n            verticalDragToForward: this.verticalDragToForward,\r\n            target: this._targetEnd.toArray(),\r\n            position: _v3A.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),\r\n            zoom: this._zoomEnd,\r\n            focalOffset: this._focalOffsetEnd.toArray(),\r\n            target0: this._target0.toArray(),\r\n            position0: this._position0.toArray(),\r\n            zoom0: this._zoom0,\r\n            focalOffset0: this._focalOffset0.toArray(),\r\n        });\r\n    }\r\n    /**\r\n     * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.\r\n     * @param json\r\n     * @param enableTransition\r\n     * @category Methods\r\n     */\r\n    fromJSON(json, enableTransition = false) {\r\n        const obj = JSON.parse(json);\r\n        this.enabled = obj.enabled;\r\n        this.minDistance = obj.minDistance;\r\n        this.maxDistance = maxNumberToInfinity(obj.maxDistance);\r\n        this.minZoom = obj.minZoom;\r\n        this.maxZoom = maxNumberToInfinity(obj.maxZoom);\r\n        this.minPolarAngle = obj.minPolarAngle;\r\n        this.maxPolarAngle = maxNumberToInfinity(obj.maxPolarAngle);\r\n        this.minAzimuthAngle = maxNumberToInfinity(obj.minAzimuthAngle);\r\n        this.maxAzimuthAngle = maxNumberToInfinity(obj.maxAzimuthAngle);\r\n        this.smoothTime = obj.smoothTime;\r\n        this.draggingSmoothTime = obj.draggingSmoothTime;\r\n        this.dollySpeed = obj.dollySpeed;\r\n        this.truckSpeed = obj.truckSpeed;\r\n        this.dollyToCursor = obj.dollyToCursor;\r\n        this.verticalDragToForward = obj.verticalDragToForward;\r\n        this._target0.fromArray(obj.target0);\r\n        this._position0.fromArray(obj.position0);\r\n        this._zoom0 = obj.zoom0;\r\n        this._focalOffset0.fromArray(obj.focalOffset0);\r\n        this.moveTo(obj.target[0], obj.target[1], obj.target[2], enableTransition);\r\n        _sphericalA.setFromVector3(_v3A.fromArray(obj.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace));\r\n        this.rotateTo(_sphericalA.theta, _sphericalA.phi, enableTransition);\r\n        this.dollyTo(_sphericalA.radius, enableTransition);\r\n        this.zoomTo(obj.zoom, enableTransition);\r\n        this.setFocalOffset(obj.focalOffset[0], obj.focalOffset[1], obj.focalOffset[2], enableTransition);\r\n        this._needsUpdate = true;\r\n    }\r\n    /**\r\n     * Attach all internal event handlers to enable drag control.\r\n     * @category Methods\r\n     */\r\n    connect(domElement) {\r\n        if (this._domElement) {\r\n            console.warn('camera-controls is already connected.');\r\n            return;\r\n        }\r\n        domElement.setAttribute('data-camera-controls-version', VERSION);\r\n        this._addAllEventListeners(domElement);\r\n        this._getClientRect(this._elementRect);\r\n    }\r\n    /**\r\n     * Detach all internal event handlers to disable drag control.\r\n     */\r\n    disconnect() {\r\n        this.cancel();\r\n        this._removeAllEventListeners();\r\n        if (this._domElement) {\r\n            this._domElement.removeAttribute('data-camera-controls-version');\r\n            this._domElement = undefined;\r\n        }\r\n    }\r\n    /**\r\n     * Dispose the cameraControls instance itself, remove all eventListeners.\r\n     * @category Methods\r\n     */\r\n    dispose() {\r\n        // remove all user event listeners\r\n        this.removeAllEventListeners();\r\n        // remove all internal event listeners\r\n        this.disconnect();\r\n    }\r\n    // it's okay to expose public though\r\n    _getTargetDirection(out) {\r\n        // divide by distance to normalize, lighter than `Vector3.prototype.normalize()`\r\n        return out.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);\r\n    }\r\n    // it's okay to expose public though\r\n    _getCameraDirection(out) {\r\n        return this._getTargetDirection(out).negate();\r\n    }\r\n    _findPointerById(pointerId) {\r\n        return this._activePointers.find((activePointer) => activePointer.pointerId === pointerId);\r\n    }\r\n    _findPointerByMouseButton(mouseButton) {\r\n        return this._activePointers.find((activePointer) => activePointer.mouseButton === mouseButton);\r\n    }\r\n    _disposePointer(pointer) {\r\n        this._activePointers.splice(this._activePointers.indexOf(pointer), 1);\r\n    }\r\n    _encloseToBoundary(position, offset, friction) {\r\n        const offsetLength2 = offset.lengthSq();\r\n        if (offsetLength2 === 0.0) { // sanity check\r\n            return position;\r\n        }\r\n        // See: https://twitter.com/FMS_Cat/status/1106508958640988161\r\n        const newTarget = _v3B.copy(offset).add(position); // target\r\n        const clampedTarget = this._boundary.clampPoint(newTarget, _v3C); // clamped target\r\n        const deltaClampedTarget = clampedTarget.sub(newTarget); // newTarget -> clampedTarget\r\n        const deltaClampedTargetLength2 = deltaClampedTarget.lengthSq(); // squared length of deltaClampedTarget\r\n        if (deltaClampedTargetLength2 === 0.0) { // when the position doesn't have to be clamped\r\n            return position.add(offset);\r\n        }\r\n        else if (deltaClampedTargetLength2 === offsetLength2) { // when the position is completely stuck\r\n            return position;\r\n        }\r\n        else if (friction === 0.0) {\r\n            return position.add(offset).add(deltaClampedTarget);\r\n        }\r\n        else {\r\n            const offsetFactor = 1.0 + friction * deltaClampedTargetLength2 / offset.dot(deltaClampedTarget);\r\n            return position\r\n                .add(_v3B.copy(offset).multiplyScalar(offsetFactor))\r\n                .add(deltaClampedTarget.multiplyScalar(1.0 - friction));\r\n        }\r\n    }\r\n    _updateNearPlaneCorners() {\r\n        if (isPerspectiveCamera(this._camera)) {\r\n            const camera = this._camera;\r\n            const near = camera.near;\r\n            const fov = camera.getEffectiveFOV() * DEG2RAD;\r\n            const heightHalf = Math.tan(fov * 0.5) * near; // near plain half height\r\n            const widthHalf = heightHalf * camera.aspect; // near plain half width\r\n            this._nearPlaneCorners[0].set(-widthHalf, -heightHalf, 0);\r\n            this._nearPlaneCorners[1].set(widthHalf, -heightHalf, 0);\r\n            this._nearPlaneCorners[2].set(widthHalf, heightHalf, 0);\r\n            this._nearPlaneCorners[3].set(-widthHalf, heightHalf, 0);\r\n        }\r\n        else if (isOrthographicCamera(this._camera)) {\r\n            const camera = this._camera;\r\n            const zoomInv = 1 / camera.zoom;\r\n            const left = camera.left * zoomInv;\r\n            const right = camera.right * zoomInv;\r\n            const top = camera.top * zoomInv;\r\n            const bottom = camera.bottom * zoomInv;\r\n            this._nearPlaneCorners[0].set(left, top, 0);\r\n            this._nearPlaneCorners[1].set(right, top, 0);\r\n            this._nearPlaneCorners[2].set(right, bottom, 0);\r\n            this._nearPlaneCorners[3].set(left, bottom, 0);\r\n        }\r\n    }\r\n    // lateUpdate\r\n    _collisionTest() {\r\n        let distance = Infinity;\r\n        const hasCollider = this.colliderMeshes.length >= 1;\r\n        if (!hasCollider)\r\n            return distance;\r\n        if (notSupportedInOrthographicCamera(this._camera, '_collisionTest'))\r\n            return distance;\r\n        const rayDirection = this._getTargetDirection(_cameraDirection);\r\n        _rotationMatrix.lookAt(_ORIGIN, rayDirection, this._camera.up);\r\n        for (let i = 0; i < 4; i++) {\r\n            const nearPlaneCorner = _v3B.copy(this._nearPlaneCorners[i]);\r\n            nearPlaneCorner.applyMatrix4(_rotationMatrix);\r\n            const origin = _v3C.addVectors(this._target, nearPlaneCorner);\r\n            _raycaster.set(origin, rayDirection);\r\n            _raycaster.far = this._spherical.radius + 1;\r\n            const intersects = _raycaster.intersectObjects(this.colliderMeshes);\r\n            if (intersects.length !== 0 && intersects[0].distance < distance) {\r\n                distance = intersects[0].distance;\r\n            }\r\n        }\r\n        return distance;\r\n    }\r\n    /**\r\n     * Get its client rect and package into given `DOMRect` .\r\n     */\r\n    _getClientRect(target) {\r\n        if (!this._domElement)\r\n            return;\r\n        const rect = this._domElement.getBoundingClientRect();\r\n        target.x = rect.left;\r\n        target.y = rect.top;\r\n        if (this._viewport) {\r\n            target.x += this._viewport.x;\r\n            target.y += rect.height - this._viewport.w - this._viewport.y;\r\n            target.width = this._viewport.z;\r\n            target.height = this._viewport.w;\r\n        }\r\n        else {\r\n            target.width = rect.width;\r\n            target.height = rect.height;\r\n        }\r\n        return target;\r\n    }\r\n    _createOnRestPromise(resolveImmediately) {\r\n        if (resolveImmediately)\r\n            return Promise.resolve();\r\n        this._hasRested = false;\r\n        this.dispatchEvent({ type: 'transitionstart' });\r\n        return new Promise((resolve) => {\r\n            const onResolve = () => {\r\n                this.removeEventListener('rest', onResolve);\r\n                resolve();\r\n            };\r\n            this.addEventListener('rest', onResolve);\r\n        });\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    _addAllEventListeners(_domElement) { }\r\n    _removeAllEventListeners() { }\r\n    /**\r\n     * backward compatible\r\n     * @deprecated use smoothTime (in seconds) instead\r\n     * @category Properties\r\n     */\r\n    get dampingFactor() {\r\n        console.warn('.dampingFactor has been deprecated. use smoothTime (in seconds) instead.');\r\n        return 0;\r\n    }\r\n    /**\r\n     * backward compatible\r\n     * @deprecated use smoothTime (in seconds) instead\r\n     * @category Properties\r\n     */\r\n    set dampingFactor(_) {\r\n        console.warn('.dampingFactor has been deprecated. use smoothTime (in seconds) instead.');\r\n    }\r\n    /**\r\n     * backward compatible\r\n     * @deprecated use draggingSmoothTime (in seconds) instead\r\n     * @category Properties\r\n     */\r\n    get draggingDampingFactor() {\r\n        console.warn('.draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.');\r\n        return 0;\r\n    }\r\n    /**\r\n     * backward compatible\r\n     * @deprecated use draggingSmoothTime (in seconds) instead\r\n     * @category Properties\r\n     */\r\n    set draggingDampingFactor(_) {\r\n        console.warn('.draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.');\r\n    }\r\n    static createBoundingSphere(object3d, out = new THREE.Sphere()) {\r\n        const boundingSphere = out;\r\n        const center = boundingSphere.center;\r\n        _box3A.makeEmpty();\r\n        // find the center\r\n        object3d.traverseVisible((object) => {\r\n            if (!object.isMesh)\r\n                return;\r\n            _box3A.expandByObject(object);\r\n        });\r\n        _box3A.getCenter(center);\r\n        // find the radius\r\n        let maxRadiusSq = 0;\r\n        object3d.traverseVisible((object) => {\r\n            if (!object.isMesh)\r\n                return;\r\n            const mesh = object;\r\n            const geometry = mesh.geometry.clone();\r\n            geometry.applyMatrix4(mesh.matrixWorld);\r\n            const bufferGeometry = geometry;\r\n            const position = bufferGeometry.attributes.position;\r\n            for (let i = 0, l = position.count; i < l; i++) {\r\n                _v3A.fromBufferAttribute(position, i);\r\n                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_v3A));\r\n            }\r\n        });\r\n        boundingSphere.radius = Math.sqrt(maxRadiusSq);\r\n        return boundingSphere;\r\n    }\r\n}\r\n\r\nexport { CameraControls as default };\r\n"],
  "mappings": "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",
  "names": ["camera", "domElement"]
}
